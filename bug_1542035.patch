# HG changeset patch
# User Bianca Danforth <bdanforth@mozilla.com>
# Date 1556821965 25200
#      Thu May 02 11:32:45 2019 -0700
# Node ID 408741fdae83b4899cc68a2de2dc0e74b0c50806
# Parent  df3eadfa74a8061f4c88496404d51baf47e21070
Bug 1542035 - Prototype extension local storage in addon developer toolbox

diff --git a/devtools/client/shared/vendor/moz.build b/devtools/client/shared/vendor/moz.build
--- a/devtools/client/shared/vendor/moz.build
+++ b/devtools/client/shared/vendor/moz.build
@@ -4,15 +4,10 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-DIRS += [
-    'stringvalidator',
-]
-
 DevToolsModules(
     'fluent-react.js',
     'fluent.js',
     'immutable.js',
-    'jsol.js',
     'jszip.js',
     'lodash.js',
     'react-dom-factories.js',
diff --git a/devtools/client/storage/ui.js b/devtools/client/storage/ui.js
--- a/devtools/client/storage/ui.js
+++ b/devtools/client/storage/ui.js
@@ -8,7 +8,7 @@
 const EventEmitter = require("devtools/shared/event-emitter");
 const {LocalizationHelper, ELLIPSIS} = require("devtools/shared/l10n");
 const KeyShortcuts = require("devtools/client/shared/key-shortcuts");
-const JSOL = require("devtools/client/shared/vendor/jsol");
+const {parseItemValue} = require("devtools/shared/storage/utils");
 const {KeyCodes} = require("devtools/client/shared/keycodes");
 const { getUnicodeHostname } = require("devtools/client/shared/unicode-url");
 
@@ -24,8 +24,6 @@ loader.lazyRequireGetter(this, "TableWid
                          "devtools/client/shared/widgets/TableWidget", true);
 loader.lazyImporter(this, "VariablesView",
                     "resource://devtools/client/shared/widgets/VariablesView.jsm");
-loader.lazyRequireGetter(this, "validator",
-                         "devtools/client/shared/vendor/stringvalidator/validator");
 
 /**
  * Localization convenience methods.
@@ -62,7 +60,6 @@ const COOKIE_KEY_MAP = {
 };
 
 const SAFE_HOSTS_PREFIXES_REGEX = /^(about:|https?:|file:|moz-extension:)/;
-const MATH_REGEX = /(?:(?:^|[-+_*/])(?:\s*-?\d+(\.\d+)?(?:[eE][+-]?\d+)?\s*))+$/;
 
 // Maximum length of item name to show in context menu label - will be
 // trimmed with ellipsis if it's longer.
@@ -756,7 +753,10 @@ class StorageUI {
       itemVar.setGrip(value);
 
       // May be the item value is a json or a key value pair itself
-      this.parseItemValue(item.name, value);
+      const obj = parseItemValue(item.name, value);
+      if (typeof obj === "object") {
+        this.populateSidebar(item.name, obj);
+      }
 
       // By default the item name and value are shown. If this is the only
       // information available, then nothing else is to be displayed.
@@ -789,7 +789,10 @@ class StorageUI {
         }
 
         mainScope.addItem(key, {}, true).setGrip(item[key]);
-        this.parseItemValue(key, item[key]);
+        const obj = parseItemValue(key, item[key]);
+        if (typeof obj === "object") {
+          this.populateSidebar(item.name, obj);
+        }
       }
     }
 
@@ -825,47 +828,13 @@ class StorageUI {
     return host;
   }
 
-  /**
-   * Tries to parse a string value into either a json or a key-value separated
-   * object and populates the sidebar with the parsed value. The value can also
-   * be a key separated array.
+  /*
+   * Populates the sidebar with a parsed object.
    *
-   * @param {string} name
-   *        The key corresponding to the `value` string in the object
-   * @param {string} originalValue
-   *        The string to be parsed into an object
+   * @param {object} obj - Either a json or a key-value separated object or a
+   * key separated array
    */
-  parseItemValue(name, originalValue) {
-    // Find if value is URLEncoded ie
-    let decodedValue = "";
-    try {
-      decodedValue = decodeURIComponent(originalValue);
-    } catch (e) {
-      // Unable to decode, nothing to do
-    }
-    const value = (decodedValue && decodedValue !== originalValue)
-      ? decodedValue : originalValue;
-
-    if (!this._shouldParse(value)) {
-      return;
-    }
-
-    let obj = null;
-    try {
-      obj = JSOL.parse(value);
-    } catch (ex) {
-      obj = null;
-    }
-
-    if (!obj && value) {
-      obj = this._extractKeyValPairs(value);
-    }
-
-    // return if obj is null, or same as value, or just a string.
-    if (!obj || obj === value || typeof obj === "string") {
-      return;
-    }
-
+  populateSidebar(name, obj) {
     const jsonObject = Object.create(null);
     const view = this.view;
     jsonObject[name] = obj;
@@ -879,97 +848,6 @@ class StorageUI {
   }
 
   /**
-   * Tries to parse a string into an object on the basis of key-value pairs,
-   * separated by various separators. If failed, tries to parse for single
-   * separator separated values to form an array.
-   *
-   * @param {string} value
-   *        The string to be parsed into an object or array
-   */
-  _extractKeyValPairs(value) {
-    const makeObject = (keySep, pairSep) => {
-      const object = {};
-      for (const pair of value.split(pairSep)) {
-        const [key, val] = pair.split(keySep);
-        object[key] = val;
-      }
-      return object;
-    };
-
-    // Possible separators.
-    const separators = ["=", ":", "~", "#", "&", "\\*", ",", "\\."];
-    // Testing for object
-    for (let i = 0; i < separators.length; i++) {
-      const kv = separators[i];
-      for (let j = 0; j < separators.length; j++) {
-        if (i == j) {
-          continue;
-        }
-        const p = separators[j];
-        const word = `[^${kv}${p}]*`;
-        const keyValue = `${word}${kv}${word}`;
-        const keyValueList = `${keyValue}(${p}${keyValue})*`;
-        const regex = new RegExp(`^${keyValueList}$`);
-        if (value.match && value.match(regex) && value.includes(kv) &&
-            (value.includes(p) || value.split(kv).length == 2)) {
-          return makeObject(kv, p);
-        }
-      }
-    }
-    // Testing for array
-    for (const p of separators) {
-      const word = `[^${p}]*`;
-      const wordList = `(${word}${p})+${word}`;
-      const regex = new RegExp(`^${wordList}$`);
-
-      if (regex.test(value)) {
-        const pNoBackslash = p.replace(/\\*/g, "");
-        return value.split(pNoBackslash);
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Check whether the value string represents something that should be
-   * displayed as text. If so then it shouldn't be parsed into a tree.
-   *
-   * @param  {String} value
-   *         The value to be parsed.
-   */
-  _shouldParse(value) {
-    const validators = [
-      "isBase64",
-      "isBoolean",
-      "isCurrency",
-      "isDataURI",
-      "isEmail",
-      "isFQDN",
-      "isHexColor",
-      "isIP",
-      "isISO8601",
-      "isMACAddress",
-      "isSemVer",
-      "isURL",
-    ];
-
-    // Check for minus calculations e.g. 8-3 because otherwise 5 will be displayed.
-    if (MATH_REGEX.test(value)) {
-      return false;
-    }
-
-    // Check for any other types that shouldn't be parsed.
-    for (const test of validators) {
-      if (validator[test](value)) {
-        return false;
-      }
-    }
-
-    // Seems like this is data that should be parsed.
-    return true;
-  }
-
-  /**
    * Select handler for the storage tree. Fetches details of the selected item
    * from the storage details and populates the storage tree.
    *
diff --git a/devtools/server/actors/storage.js b/devtools/server/actors/storage.js
--- a/devtools/server/actors/storage.js
+++ b/devtools/server/actors/storage.js
@@ -12,12 +12,17 @@ const Services = require("Services");
 const defer = require("devtools/shared/defer");
 const {isWindowIncluded} = require("devtools/shared/layout/utils");
 const specs = require("devtools/shared/specs/storage");
+const {parseItemValue} = require("devtools/shared/storage/utils");
+const {ExtensionProcessScript} = require("resource://gre/modules/ExtensionProcessScript.jsm");
+const {ExtensionStorageIDB} = require("resource://gre/modules/ExtensionStorageIDB.jsm");
 
 const CHROME_ENABLED_PREF = "devtools.chrome.enabled";
 const REMOTE_ENABLED_PREF = "devtools.debugger.remote-enabled";
 
 const DEFAULT_VALUE = "value";
 
+const DEVTOOLS_EXT_STORAGELOCAL_CHANGED = "Extension:DevTools:OnStorageLocalChanged";
+
 loader.lazyRequireGetter(this, "naturalSortCaseInsensitive",
   "devtools/client/shared/natural-sort", true);
 
@@ -1298,6 +1303,442 @@ StorageActors.createActor({
   observationTopics: ["dom-storage2-changed", "dom-private-storage2-changed"],
 }, getObjectForLocalOrSessionStorage("sessionStorage"));
 
+const extensionStorageHelpers = {
+  unresolvedPromises: new Map(),
+  onChangedListeners: new Map(),
+
+  // Sets the parent process message manager
+  setPpmm(ppmm) {
+    this.ppmm = ppmm;
+  },
+
+  // A promise in the main process has resolved, and we need to pass the return value(s)
+  // back to the child process
+  backToChild(...args) {
+    Services.mm.broadcastAsyncMessage("debug:storage-extensionStorage-request-child", {
+      method: "backToChild",
+      args: args,
+    });
+  },
+
+  // The main process does not require an extension context to select the backend
+  async selectBackendInParent(addonId) {
+    const {WebExtensionPolicy} = Cu.getGlobalForObject(require("resource://gre/modules/XPCOMUtils.jsm"));
+    const {extension} = WebExtensionPolicy.getByID(addonId);
+    const parentResult = await ExtensionStorageIDB.selectBackend({extension});
+    const result = {
+      ...parentResult,
+      // We have to deserialize the result here before sending it back to the
+      // child process, otherwise we get the StructuredCloneHolder object for
+      // storagePrincipal instead
+      storagePrincipal: parentResult.storagePrincipal.deserialize(this, true),
+    };
+
+    // Subscribe a listener for the storage.onChanged API event notifications
+    // and keep track of it to remove it when the debugger is being disconnected.
+    const messageName = `Extension:StorageLocalOnChanged:${extension.uuid}`;
+    const onChangedListener = ({name, data}) => {
+      Services.mm.broadcastAsyncMessage(DEVTOOLS_EXT_STORAGELOCAL_CHANGED, {
+        changes: data,
+        extensionUUID: extension.uuid,
+      });
+    };
+    Services.ppmm.addMessageListener(messageName, onChangedListener);
+    this.onChangedListeners.set(messageName, onChangedListener);
+    return this.backToChild("selectBackendInParent", result);
+  },
+
+  onDisconnected() {
+    // Remove any listener subscribed to intercept storage.onChanged API events.
+    for (const [messageName, listener] of this.onChangedListeners) {
+      Services.ppmm.removeMessageListener(messageName, listener);
+    }
+  },
+
+  // Runs in the main process. This determines what code to execute based on the message
+  // received from the child process.
+  async handleChildRequest(msg) {
+    switch (msg.json.method) {
+      case "selectBackendInParent": {
+        const addonId = msg.data.args[0];
+        const result = await extensionStorageHelpers.selectBackendInParent(addonId);
+        return result;
+      }
+      default:
+        console.error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD", msg.json.method);
+        throw new Error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD");
+    }
+  },
+  // Runs in the child process. This determines what code to execute based on the message
+  // received from the parent process.
+  handleParentRequest(msg) {
+    switch (msg.json.method) {
+      case "backToChild": {
+        const [func, rv] = msg.json.args;
+        const deferred = this.unresolvedPromises.get(func);
+        if (deferred) {
+          this.unresolvedPromises.delete(func);
+          deferred.resolve(rv);
+        }
+        break;
+      }
+      default:
+        console.error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD", msg.json.method);
+        throw new Error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD");
+    }
+  },
+  callParentProcessAsync(methodName, ...args) {
+    const deferred = defer();
+
+    this.unresolvedPromises.set(methodName, deferred);
+
+    this.ppmm.sendAsyncMessage("debug:storage-extensionStorage-request-parent", {
+      method: methodName,
+      args: args,
+    });
+
+    return deferred.promise;
+  },
+};
+
+/**
+ * E10S parent/child setup helpers
+ * Add a message listener in the parent process to receive messages from the child
+ * process.
+ */
+exports.setupParentProcessForExtensionStorage = function({mm, prefix}) {
+  // listen for director-script requests from the child process
+  setMessageManager(mm);
+
+  function setMessageManager(newMM) {
+    if (mm) {
+      mm.removeMessageListener("debug:storage-extensionStorage-request-parent",
+                               extensionStorageHelpers.handleChildRequest);
+    }
+    mm = newMM;
+    if (mm) {
+      mm.addMessageListener("debug:storage-extensionStorage-request-parent",
+                            extensionStorageHelpers.handleChildRequest);
+    }
+  }
+
+  return {
+    onBrowserSwap: setMessageManager,
+    onDisconnected: () => {
+      // Although "disconnected-from-child" implies that the child is already
+      // disconnected this is not the case. The disconnection takes place after
+      // this method has finished. This gives us chance to clean up items within
+      // the parent process e.g. observers.
+      setMessageManager(null);
+      extensionStorageHelpers.onDisconnected();
+    },
+  };
+};
+
+/**
+* The Extension Storage actor.
+*/
+StorageActors.createActor({
+  typeName: "extensionStorage",
+}, {
+  initialize(storageActor) {
+    protocol.Actor.prototype.initialize.call(this, null);
+
+    this.storageActor = storageActor;
+
+    this.addonId = this.storageActor.parentActor.addonId;
+
+    // Map<host, ExtensionStorageIDB db connection>
+    this.dbConnectionForHost = new Map();
+
+    this.setupChildProcess();
+
+    this.onStorageChange = this.onStorageChange.bind(this);
+
+    this.conn.parentMessageManager.addMessageListener(
+      DEVTOOLS_EXT_STORAGELOCAL_CHANGED, this.onStorageChange);
+
+    this.populateStoresForHosts();
+
+    this.onWindowReady = this.onWindowReady.bind(this);
+    this.onWindowDestroyed = this.onWindowDestroyed.bind(this);
+    this.storageActor.on("window-ready", this.onWindowReady);
+    this.storageActor.on("window-destroyed", this.onWindowDestroyed);
+  },
+
+  destroy() {
+    this.conn.parentMessageManager.removeMessageListener(
+      DEVTOOLS_EXT_STORAGELOCAL_CHANGED, this.onStorageChange);
+
+    this.storageActor.off("window-ready", this.onWindowReady);
+    this.storageActor.off("window-destroyed", this.onWindowDestroyed);
+
+    this.hostVsStores.clear();
+
+    protocol.Actor.prototype.destroy.call(this);
+
+    this.storageActor = null;
+  },
+
+  setupChildProcess() {
+    const ppmm = this.conn.parentMessageManager;
+    extensionStorageHelpers.setPpmm(ppmm);
+
+    this.conn.setupInParent({
+      module: "devtools/server/actors/storage",
+      setupParent: "setupParentProcessForExtensionStorage",
+    });
+
+    this.selectBackendInParent =
+      extensionStorageHelpers.callParentProcessAsync.bind(
+        extensionStorageHelpers,
+        "selectBackendInParent"
+      );
+
+    // Add a message listener in the child process to receive messages from the parent
+    // process
+    ppmm.addMessageListener(
+      "debug:storage-extensionStorage-request-child",
+      extensionStorageHelpers.handleParentRequest.bind(extensionStorageHelpers),
+    );
+  },
+
+  /**
+  * This fires when the extension changes storage data while the storage
+  * inspector is open. Ensures this.hostVsStores stays up-to-date and
+  * passes the change on to update the view.
+  */
+  onStorageChange({name, data}) {
+    const host = `moz-extension://${data.extensionUUID}`;
+    const changes = data.changes;
+    const storeMap = this.hostVsStores.get(host);
+    if (!storeMap) {
+      return;
+    }
+
+    for (const key in changes) {
+      const storageChange = changes[key];
+      const {newValue, oldValue} = storageChange;
+
+      let action;
+      if (typeof newValue === "undefined") {
+        action = "deleted";
+        storeMap.delete(key);
+      } else if (typeof oldValue === "undefined") {
+        action = "added";
+        storeMap.set(key, newValue);
+      } else {
+        action = "changed";
+        storeMap.set(key, newValue);
+      }
+
+      this.storageActor.update(action, this.typeName, {[host]: [key]});
+    }
+  },
+
+  /**
+   * Purpose of this method is same as populateStoresForHosts but this is async.
+   * This exact same operation cannot be performed in populateStoresForHosts
+   * method, as that method is called in initialize method of the actor, which
+   * cannot be asynchronous.
+   */
+  async preListStores() {
+    this.hostVsStores = new Map();
+
+    for (const window of this.windows) {
+      let host = this.getHostName(window.location);
+      if (!host) {
+        const extension = ExtensionProcessScript.getExtensionChild(this.addonId);
+        host = `moz-extension://${extension.uuid}`;
+      }
+      await this.populateStoresForHost(host, window);
+    }
+  },
+
+  /**
+   * This method is overriden and left blank as for extensionStorage, this operation
+   * cannot be performed synchronously. Thus, the preListStores method exists to
+   * do the same task asynchronously.
+   */
+  populateStoresForHosts() {},
+
+  /**
+  * This method asynchronously reads the browser.storage.local data for the target
+  * extension if it has the storage permission and caches this data into
+  * this.hostVsStores.
+  * @param {String} host - the hostname for the extension
+  */
+  async populateStoresForHost(host) {
+    if (this.hostVsStores.has(host)) {
+      return;
+    }
+
+    const extension = ExtensionProcessScript.getExtensionChild(this.addonId);
+    if (!extension || !(extension.hasPermission("storage"))) {
+      return;
+    }
+
+    const storagePrincipal = await this.getStoragePrincipal(extension);
+
+    if (!storagePrincipal) {
+      return;
+    }
+
+    const db = await ExtensionStorageIDB.open(storagePrincipal);
+    this.dbConnectionForHost.set(host, db);
+    const data = await db.get();
+
+    const storeMap = new Map();
+    for (const [key, value] of Object.entries(data)) {
+      storeMap.set(key, value);
+    }
+
+    this.hostVsStores.set(host, storeMap);
+
+    // Show the storage actor in the add-on storage inspector even when there
+    // is no extension page currently open
+    const storageData = {};
+    storageData[host] = this.getNamesForHost(host);
+    this.storageActor.update("added", this.typeName, storageData);
+  },
+
+  async getStoragePrincipal(extension) {
+    const {
+      backendEnabled,
+      storagePrincipal,
+    } = await this.selectBackendInParent(extension.id);
+
+    if (!backendEnabled) {
+      // IDB backend disabled; give up.
+      return null;
+    }
+    return storagePrincipal;
+  },
+
+  getValuesForHost(host, name) {
+    const result = [];
+
+    if (!this.hostVsStores.has(host)) {
+      return result;
+    }
+
+    if (name) {
+      return [{name, value: this.hostVsStores.get(host).get(name)}];
+    }
+
+    for (const [key, value] of Array.from(this.hostVsStores.get(host).entries())) {
+      result.push({name: key, value});
+    }
+    return result;
+  },
+
+  /**
+   * This method converts the values returned by getValuesForHost into a StoreObject
+   * (currently based off of this same method for IndexedDB).
+   */
+  toStoreObject({name, value}) {
+    if (!{name, value}) {
+      return null;
+    }
+
+    // Stringify adds redundant quotes to strings
+    if (typeof value !== "string") {
+      // Not all possible values are stringifiable (e.g. functions)
+      value = JSON.stringify(value) || "Object";
+    }
+
+    // FIXME: Bug 1318029 - Due to a bug that is thrown whenever a
+    // LongStringActor string reaches DebuggerServer.LONG_STRING_LENGTH we need
+    // to trim the value. When the bug is fixed we should stop trimming the
+    // string here.
+    const maxLength = DebuggerServer.LONG_STRING_LENGTH - 1;
+    if (value.length > maxLength) {
+      value = value.substr(0, maxLength);
+    }
+
+    return {
+      name,
+      value: new LongStringActor(this.conn, value || ""),
+    };
+  },
+
+  getFields() {
+    return [
+      // name needs to be editable for the addItem case, where a temporary key-value
+      // pair is created that can later be edited via editItem.
+      { name: "name", editable: true },
+      { name: "value", editable: true },
+    ];
+  },
+
+  async addItem(guid, host) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+    const changes = await db.set({[guid]: DEFAULT_VALUE});
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async editItem({host, field, items, oldValue}) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const {name, value} = items;
+    // If the name changed, remove the previous entry in storage by the old name first
+    if (field === "name") {
+      const changes = await db.remove(oldValue);
+      this.fireOnChangedExtensionEvent(host, changes);
+    }
+
+    // Attempt to interpret the data type of the value
+    let newValue = parseItemValue(name, value);
+    if (newValue === value) {
+      try {
+        newValue = JSON.parse(value);
+      } catch (error) {
+        // Value couldn't be parsed; just use what we started with
+        newValue = value;
+      }
+    }
+
+    const changes = await db.set({[name]: newValue});
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async removeItem(host, name) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const changes = await db.remove(name);
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async removeAll(host) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const changes = await db.clear();
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  /**
+  * Let the extension know that storage data has been changed by the user from
+  * the storage inspector.
+  */
+  fireOnChangedExtensionEvent(host, changes) {
+    const uuid = (new URL(host)).host;
+    Services.cpmm.sendAsyncMessage(`Extension:StorageLocalOnChanged:${uuid}`,
+                                   changes);
+  },
+});
+
 StorageActors.createActor({
   typeName: "Cache",
 }, {
diff --git a/devtools/server/tests/browser/browser.ini b/devtools/server/tests/browser/browser.ini
--- a/devtools/server/tests/browser/browser.ini
+++ b/devtools/server/tests/browser/browser.ini
@@ -127,6 +127,7 @@ skip-if = e10s # Bug 1183605 - devtools/
 [browser_storage_listings.js]
 [browser_storage_updates.js]
 skip-if = (verify && debug && (os == 'mac' || os == 'linux'))
+[browser_storage_webext_storage_local.js]
 [browser_stylesheets_getTextEmpty.js]
 [browser_stylesheets_nested-iframes.js]
 [browser_register_actor.js]
diff --git a/devtools/server/tests/browser/browser_storage_webext_storage_local.js b/devtools/server/tests/browser/browser_storage_webext_storage_local.js
new file mode 100644
--- /dev/null
+++ b/devtools/server/tests/browser/browser_storage_webext_storage_local.js
@@ -0,0 +1,532 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/* globals browser */
+
+"use strict";
+
+/**
+* This test verifies that web extension local storage (i.e. `browser.storage.local`)
+* data is correctly synced between the `about:debugging` toolbox's Storage panel and a
+* test extension.
+*/
+
+const {Toolbox} = require("devtools/client/framework/toolbox");
+
+/**
+* Starts up and connects the Debugger server to the DevTools client (both in the main
+* process) by listening over an nsIPipe, so that they can send remote debugging
+* protocol messages to each other.
+* @return {Promise} Resolves with a client object when the debugger has started up.
+*/
+async function startDebugger() {
+  initDebuggerServer();
+  const transport = DebuggerServer.connectPipe();
+  const client = new DebuggerClient(transport);
+  await client.connect();
+  return client;
+}
+
+/**
+* Set up and optionally open the `about:debugging` toolbox for a given extension.
+* @param {String} extensionId - The id for the extension to be targeted by the toolbox.
+* @param {Object} options - Configuration options with various optional fields:
+*   - {Boolean} openToolbox - If true, open the toolbox
+* @return {Promise} Resolves with a web extension actor front and target objects and a
+* toolbox object when the toolbox has been setup
+*/
+async function setupExtensionDebuggingToolbox(extensionId, options = {}) {
+  const {openToolbox = false} = options;
+
+  const client = await startDebugger();
+  const front = await client.mainRoot.getAddon({id: extensionId});
+  // Starts a DevTools server in the extension child process.
+  const target = await front.connect(); // JSON representation of the actor
+
+  const toolbox = openToolbox ?
+    await gDevTools.showToolbox(target, null, Toolbox.HostType.WINDOW) : null;
+
+  return {front, target, toolbox};
+}
+
+/**
+* Builds the extension configuration object passed into ExtensionTestUtils.loadExtension
+* @param {Object} - Options, if any, to add to the configuration
+* @param {Function} options.background - A function comprising the test extension's
+* background script if provided
+* @param {Object} options.files - An object whose keys correspond to file names and
+* values map to the file contents
+* @return {Object} - The extension configuration object
+*/
+function getExtensionConfig(options = {}) {
+  const baseConfig = {
+    manifest: {
+      permissions: ["storage"],
+    },
+    useAddonManager: "temporary",
+  };
+
+  return {
+    ...baseConfig,
+    ...options,
+  };
+}
+
+/**
+* Gets the extensionStorage store object from the storage actor in the extension process
+* for the target extension
+* @param {Object} target
+* @return {Promise} Resolves with an extensionStorage store object else null when all
+* stores have been obtained
+*/
+async function getExtensionStorage(target) {
+  const storageFront = await target.getFront("storage");
+  const stores = await storageFront.listStores();
+  return (stores.extensionStorage || null);
+}
+
+/**
+* Shutdown procedure common to all tasks.
+* @param {Object} extension - The test extension
+* @param {Object} target - The web extension actor targeted by the DevTools client
+*/
+async function shutdown(extension, target) {
+  if (target) {
+    await target.destroy();
+  }
+  await extension.unload();
+}
+
+/**
+* A generic extension script that can be used in any extension context (e.g. a
+* background script or an extension page script loaded in a tab).
+*/
+async function extensionScriptWithMessageListener() {
+  let valType;
+  browser.test.onMessage.addListener(async (msg, ...args) => {
+    switch (msg) {
+      case "storage-local-set":
+        await browser.storage.local.set(args[0]);
+        const item = args[0];
+        valType = typeof item[Object.keys(item)[0]];
+        await browser.storage.local.set(item);
+        break;
+      case "storage-local-get":
+        const {key} = args[0];
+        valType = args[0].valType || valType;
+        const value = (await browser.storage.local.get(key))[key];
+        browser.test.assertTrue(
+          (typeof value === valType),
+          "The data type for the storage item's value is unchanged."
+        );
+        break;
+      default:
+        browser.test.fail(`Unexpected test message: ${msg}`);
+    }
+
+    browser.test.sendMessage(`${msg}:done`);
+  });
+  browser.test.sendMessage("extension-origin", window.location.origin);
+}
+
+/**
+* Shared files for a test extension that has no background page but adds storage
+* items via a transient extension page in a tab
+*/
+const ext_no_bg = {
+  files: {
+    "extension_page_in_tab.html": `<!DOCTYPE html>
+      <html>
+        <head>
+          <meta charset="utf-8">
+        </head>
+        <body>
+          <h1>Extension Page in a Tab</h1>
+          <script src="extension_page_in_tab.js"></script>
+        </body>
+      </html>`,
+    "extension_page_in_tab.js": extensionScriptWithMessageListener,
+  },
+};
+
+add_task(async function test_extension_store_exists() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig());
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  const extensionStorage = await getExtensionStorage(target);
+  ok(extensionStorage, "Should have an extensionStorage store");
+
+  await shutdown(extension, target);
+});
+
+add_task(async function test_extension_origin_matches_debugger_target() {
+  async function background() {
+    browser.test.sendMessage("extension-origin", window.location.origin);
+  }
+
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background})
+  );
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  const {hosts} = await getExtensionStorage(target);
+  const expectedHost = await extension.awaitMessage("extension-origin");
+  ok(expectedHost in hosts,
+     "Should have the expected extension host in the extensionStorage store");
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: Bg page adds item while inspector is open.
+* - Load extension with background page.
+* - Open the add-on inspector.
+* - With the inspector still open, add an item from the background page.
+* - The data in the inspector should match the item added by the extension.
+*/
+add_task(async function test_local_storage_live_update() {
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background: extensionScriptWithMessageListener})
+  );
+
+  await extension.startup();
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  let {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(data, [], "Got the expected results on empty storage.local");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  data = (await extensionStorage.getStoreObjects(host)).data;
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [{name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: No bg page. Transient page adds item before inspector opened.
+* - Load extension with no background page.
+* - Open an extension page in a tab that adds a local storage item.
+* - With the extension page still open, open the add-on inspector.
+* - The data in the inspector should match the items added by the extension.
+*/
+add_task(async function test_local_storage_ext_no_bg_with_ext_page_open() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig({
+    files: ext_no_bg.files,
+  }));
+
+  await extension.startup();
+
+  const url = `moz-extension://${extension.uuid}/extension_page_in_tab.html`;
+  BrowserTestUtils.addTab(gBrowser, url);
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  const {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [{name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: No bg page. Transient page adds item, then closes before inspector opened.
+* - Load extension with no background page.
+* - Open an extension page in a tab that adds a local storage item.
+* - Close all extension pages.
+* - Open the add-on inspector.
+* - The data in the inspector should match the item added by the extension.
+*/
+add_task(async function test_local_storage_ext_no_bg_with_no_ext_page_open() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig({
+    files: ext_no_bg.files,
+  }));
+
+  await extension.startup();
+
+  const url = `moz-extension://${extension.uuid}/extension_page_in_tab.html`;
+  const tab = BrowserTestUtils.addTab(gBrowser, url);
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  BrowserTestUtils.removeTab(tab);
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  const {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [{name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: No bg page. Inspector live updates when a transient page adds an item.
+* - Load extension with no background page.
+* - Open the add-on storage inspector.
+* - With the inspector still open, open an extension page in a new tab that adds an item.
+* - Assert:
+*   - The data in the inspector should live update to match the item added by the
+*     extension.
+*   - If an extension page adds the same data again, the data in the inspector should
+*     not change.
+*/
+add_task(async function test_local_storage_ext_no_bg_live_update() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig({
+    files: ext_no_bg.files,
+  }));
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  const url = `moz-extension://${extension.uuid}/extension_page_in_tab.html`;
+  BrowserTestUtils.addTab(gBrowser, url);
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  let {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(data, [], "Got the expected results on empty storage.local");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  data = (await extensionStorage.getStoreObjects(host)).data;
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [{name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  data = (await extensionStorage.getStoreObjects(host)).data;
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [{name: "a", value: {str: "123"}}],
+    "The results are unchanged when an extension page adds duplicate items"
+  );
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: Bg page adds item while inspector is open. Inspector edits item's value.
+* - Load extension with background page.
+* - Open the add-on inspector.
+* - With the inspector still open, add item from the background page.
+* - Edit the value of the item in the inspector
+* - Assert:
+*   - The data in the inspector should match the item added by the extension.
+*   - The storage actor is not mutating the item value's data type
+*     when the item's value is edited in the inspector
+*/
+add_task(async function test_local_storage_value_data_types_unchanged() {
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background: extensionScriptWithMessageListener})
+  );
+
+  await extension.startup();
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  /*
+  * Compares the data type for the modified value of a storage item between
+  * the extension and the inspector.
+  * @param {Object} item - The storage item to modify
+  * @param {string} newVal - The new value for the storage item, expressed as a string
+  * @param {string} valType - The expected result of 'typeof' once newValue is parsed
+  * in the storage actor
+  * @param {Boolean} inExtension - True if the item's value should be modified
+  * by the extension. False if it should be modified by the storage inspector.
+  * @param {string} parsedVal - Optional - The parsed value obtained in the storage actor.
+  * This is useful for objects where spaces and escape characters can cause two
+  * functionally equivalent values to fail a strict equals check.
+  */
+  async function verifyItemValueType(item, newVal, valType, inExtension, parsedVal) {
+    const key = Object.keys(item)[0];
+    const oldValue = item[key];
+
+    if (inExtension) {
+      extension.sendMessage("storage-local-set", item);
+      await extension.awaitMessage("storage-local-set:done");
+    } else {
+      await extensionStorage.editItem({
+        host,
+        field: "value",
+        items: {name: key, value: newVal},
+        oldValue,
+      });
+    }
+
+    const {data} = await extensionStorage.getStoreObjects(host);
+    Assert.deepEqual(
+      data,
+      // The view layer is separate from the database layer; therefore
+      // while the storage actor does change a copy of the value to be a
+      // LongStringActor for the view (by way of `toStoreObject`, the
+      // value's data type in the database is unchanged, as demonstrated
+      // by the next assertion in the test extension.
+      [{
+        name: key,
+        value: {str: parsedVal || newVal},
+      }],
+      "Got the expected results on populated storage.local"
+    );
+
+    // The extension asserts the data type is unchanged
+    extension.sendMessage("storage-local-get", {key, valType});
+    await extension.awaitMessage("storage-local-get:done");
+  }
+
+  await verifyItemValueType({a: 123}, "123", "number", true);
+
+  await verifyItemValueType({a: 123}, "true", "boolean", false);
+
+  await verifyItemValueType({a: 123}, "hi", "string", false);
+
+  await verifyItemValueType({a: 123}, "{b: 789}", "object", false, "{\"b\":789}");
+
+  await verifyItemValueType({a: 123}, "[1, 2, 3]", "object", false, "[1,2,3]");
+
+  await verifyItemValueType({a: 123}, "null", "object", false);
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: Inspector shows extension storage data added prior to extension startup
+* - Load extension that adds a storage item
+* - Uninstall the extension
+* - Reinstall the extension
+* - Open the add-on storage inspector.
+* - The data in the inspector should match the data added the first time the extension
+*   was installed
+* Related test case: Inspector shows extension storage data when an extension that has
+* already migrated to the IndexedDB storage backend prior to extension startup adds
+* another storage item.
+* - (Building from previous steps)
+* - The reinstalled extension adds a storage item
+* - The data in the inspector should live update with both items: the item added from the
+*   first and the item added from the reinstall.
+* Note: Make sure this task is the last task in the file, since it uses
+* SpecialPowers.pushPrefEnv, and none of our other tasks need these test preferences set.
+*/
+add_task(async function test_local_storage_ext_data_added_prior_to_ext_startup() {
+  // Use a test-only pref to leave the addonid->uuid mapping around after
+  // uninstall so that we can re-attach to the same storage (this prefEnv
+  // is kept for this entire file and cleared automatically once all the
+  // tests in this file have been executed).
+  await SpecialPowers.pushPrefEnv({
+    set: [["extensions.webextensions.keepUuidOnUninstall", true]],
+  });
+
+  // Set the pref to prevent cleaning up storage on uninstall in a separate prefEnv
+  // so we can pop it below, leaving flags set in the previous prefEnvs unmodified.
+  await SpecialPowers.pushPrefEnv({
+    set: [["extensions.webextensions.keepStorageOnUninstall", true]],
+  });
+
+  let extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background: extensionScriptWithMessageListener})
+  );
+
+  await extension.startup();
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  await shutdown(extension);
+
+  // Reinstall the same extension
+  extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background: extensionScriptWithMessageListener})
+  );
+
+  await extension.startup();
+
+  await extension.awaitMessage("extension-origin");
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  let {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [{name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  // Related test case
+  extension.sendMessage("storage-local-set", {b: 456});
+  await extension.awaitMessage("storage-local-set:done");
+
+  data = (await extensionStorage.getStoreObjects(host)).data;
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [
+      {name: "a", value: {str: "123"}},
+      {name: "b", value: {str: "456"}},
+    ],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
diff --git a/devtools/server/tests/unit/test_extension_storage_actor.js b/devtools/server/tests/unit/test_extension_storage_actor.js
new file mode 100644
--- /dev/null
+++ b/devtools/server/tests/unit/test_extension_storage_actor.js
@@ -0,0 +1,151 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/* globals browser */
+
+"use strict";
+
+const {
+  AddonTestUtils,
+} = ChromeUtils.import("resource://testing-common/AddonTestUtils.jsm");
+
+const {
+  FileUtils,
+} = ChromeUtils.import("resource://gre/modules/FileUtils.jsm");
+
+const {
+  ExtensionTestUtils,
+} = ChromeUtils.import("resource://testing-common/ExtensionXPCShellUtils.jsm");
+
+const {
+  createAppInfo,
+  promiseStartupManager,
+} = AddonTestUtils;
+
+AddonTestUtils.init(this);
+createAppInfo("xpcshell@tests.mozilla.org", "XPCShell", "1", "42");
+
+ExtensionTestUtils.init(this);
+
+/**
+ * Starts up and connects the Debugger server to the DevTools client (both in the main
+ * process) by listening over an nsIPipe, so that they can send remote debugging
+ * protocol messages to each other.
+ * @return {Promise} Resolves with a client object when the debugger has started up.
+ */
+async function startDebugger() {
+  DebuggerServer.init();
+  DebuggerServer.registerAllActors();
+  const transport = DebuggerServer.connectPipe();
+  const client = new DebuggerClient(transport);
+  await client.connect();
+  return client;
+}
+
+/**
+ * Set up DebuggerClient for a given extension.
+ * @param {String} extensionId - The id for the extension to be targeted by the toolbox.
+ * @return {Promise} Resolves with a web extension actor front and target objects and a
+ * toolbox object when the toolbox has been setup
+ */
+async function setupExtensionDebugging(extensionId) {
+  const client = await startDebugger();
+  const front = await client.mainRoot.getAddon({id: extensionId});
+  // Starts a DevTools server in the extension child process.
+  const target = await front.connect(); // JSON representation of the actor
+  return {front, target};
+}
+
+/**
+ * Builds the extension configuration object passed into ExtensionTestUtils.loadExtension
+ * @param {Object} - Options, if any, to add to the configuration
+ * @param {Function} options.background - A function comprising the test extension's
+ * background script if provided
+ * @param {Object} options.files - An object whose keys correspond to file names and
+ * values map to the file contents
+ * @return {Object} - The extension configuration object
+ */
+function getExtensionConfig({background, files} = {}) {
+  const baseConfig = {
+    manifest: {
+      permissions: ["storage"],
+    },
+    useAddonManager: "temporary",
+  };
+  // TODO: This is ugly and hard to follow; consider a switch statement or other approach
+  if (!background && !files) {
+    return baseConfig;
+  } else if (files) {
+    return {
+      files,
+      ...baseConfig,
+    };
+  } else if (background) {
+    return {
+      background,
+      ...baseConfig,
+    };
+  }
+  return {
+    background,
+    files,
+    ...baseConfig,
+  };
+}
+
+/**
+ * Gets the extensionStorage store object from the storage actor in the extension process
+ * for the target extension
+ * @param {Object} target
+ * @return {Promise} Resolves with an extensionStorage store object else null when all
+ * stores have been obtained
+ */
+async function getExtensionStorage(target) {
+  const storageFront = await target.getFront("storage");
+  const stores = await storageFront.listStores();
+  return (stores.extensionStorage || null);
+}
+
+/**
+ * Shutdown procedure common to all tasks.
+ * @param {Object} extension - The test extension
+ * @param {Object} target - The web extension actor targeted by the DevTools client
+ */
+async function shutdown(extension, target) {
+  await target.destroy();
+  await extension.unload();
+}
+
+/**
+ * Mocks the missing 'storage/permanent' directory needed by the "indexedDB"
+ * storage actor's preListStores method (called when 'listStores' is called). This
+ * directory exists in a full browser i.e. mochitest.
+ */
+function createMissingIndexedDBDirs() {
+  const dir = (Services.dirsvc.get("ProfD", Ci.nsIFile)).clone();
+  dir.append("storage");
+  if (!dir.exists()) {
+    dir.create(dir.DIRECTORY_TYPE, FileUtils.PERMS_DIRECTORY);
+  }
+  dir.append("permanent");
+  if (!dir.exists()) {
+    dir.create(dir.DIRECTORY_TYPE, FileUtils.PERMS_DIRECTORY);
+  }
+  Assert.ok(dir.exists(), "Should have a 'storage/permanent' dir in the profile dir");
+}
+
+add_task(async function setup() {
+  await promiseStartupManager();
+  createMissingIndexedDBDirs();
+});
+
+add_task(async function test_extension_store_exists() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig());
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebugging(extension.id);
+  const extensionStorage = await getExtensionStorage(target);
+  ok(extensionStorage, "Should have an extensionStorage store");
+  await shutdown(extension, target);
+});
diff --git a/devtools/server/tests/unit/xpcshell.ini b/devtools/server/tests/unit/xpcshell.ini
--- a/devtools/server/tests/unit/xpcshell.ini
+++ b/devtools/server/tests/unit/xpcshell.ini
@@ -59,6 +59,7 @@ support-files =
 [test_blackboxing-05.js]
 [test_blackboxing-07.js]
 [test_blackboxing-08.js]
+[test_extension_storage_actor.js]
 [test_frameactor-01.js]
 [test_frameactor-02.js]
 [test_frameactor-03.js]
diff --git a/devtools/shared/moz.build b/devtools/shared/moz.build
--- a/devtools/shared/moz.build
+++ b/devtools/shared/moz.build
@@ -27,6 +27,7 @@ DIRS += [
     'security',
     'sprintfjs',
     'specs',
+    'storage',
     'transport',
     'webconsole',
     'worker',
diff --git a/devtools/shared/specs/storage.js b/devtools/shared/specs/storage.js
--- a/devtools/shared/specs/storage.js
+++ b/devtools/shared/specs/storage.js
@@ -163,6 +163,40 @@ createStorageSpec({
   methods: storageMethods,
 });
 
+// TODO: create a new storeObjectType, since extension storage is less
+// restrictive than localStorage/sessionStorage and more restrictive than
+// IndexedDB.
+// Extension store object
+types.addDictType("extensionobject", {
+  name: "nullable:string",
+  value: "nullable:longstring",
+});
+
+// Array of Extension Storage store objects
+types.addDictType("extensionstoreobject", {
+  total: "number",
+  offset: "number",
+  data: "array:nullable:extensionobject",
+});
+
+createStorageSpec({
+  typeName: "extensionStorage",
+  storeObjectType: "extensionstoreobject",
+  methods: {
+    // TODO: May want to define storageMethods differently compared to
+    // localStorage and sessionStorage...
+    ...storageMethods,
+    addExtensionStorageListeners: {
+      request: {},
+      response: {},
+    },
+    removeExtensionStorageListeners: {
+      request: {},
+      response: {},
+    },
+  },
+});
+
 types.addDictType("cacheobject", {
   "url": "string",
   "status": "string",
diff --git a/devtools/shared/storage/moz.build b/devtools/shared/storage/moz.build
new file mode 100644
--- /dev/null
+++ b/devtools/shared/storage/moz.build
@@ -0,0 +1,13 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DIRS += [
+    'vendor'
+]
+
+DevToolsModules(
+    'utils.js'
+)
diff --git a/devtools/shared/storage/utils.js b/devtools/shared/storage/utils.js
new file mode 100644
--- /dev/null
+++ b/devtools/shared/storage/utils.js
@@ -0,0 +1,148 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const validator = require("devtools/shared/storage/vendor/stringvalidator/validator");
+const JSOL = require("devtools/shared/storage/vendor/jsol");
+
+const MATH_REGEX = /(?:(?:^|[-+_*/])(?:\s*-?\d+(\.\d+)?(?:[eE][+-]?\d+)?\s*))+$/;
+
+/**
+ * Tries to parse a string into an object on the basis of key-value pairs,
+ * separated by various separators. If failed, tries to parse for single
+ * separator separated values to form an array.
+ *
+ * @param {string} value
+ *        The string to be parsed into an object or array
+ */
+function _extractKeyValPairs(value) {
+  const makeObject = (keySep, pairSep) => {
+    const object = {};
+    for (const pair of value.split(pairSep)) {
+      const [key, val] = pair.split(keySep);
+      object[key] = val;
+    }
+    return object;
+  };
+
+  // Possible separators.
+  const separators = ["=", ":", "~", "#", "&", "\\*", ",", "\\."];
+  // Testing for object
+  for (let i = 0; i < separators.length; i++) {
+    const kv = separators[i];
+    for (let j = 0; j < separators.length; j++) {
+      if (i == j) {
+        continue;
+      }
+      const p = separators[j];
+      const word = `[^${kv}${p}]*`;
+      const keyValue = `${word}${kv}${word}`;
+      const keyValueList = `${keyValue}(${p}${keyValue})*`;
+      const regex = new RegExp(`^${keyValueList}$`);
+      if (value.match && value.match(regex) && value.includes(kv) &&
+          (value.includes(p) || value.split(kv).length == 2)) {
+        return makeObject(kv, p);
+      }
+    }
+  }
+  // Testing for array
+  for (const p of separators) {
+    const word = `[^${p}]*`;
+    const wordList = `(${word}${p})+${word}`;
+    const regex = new RegExp(`^${wordList}$`);
+
+    if (regex.test(value)) {
+      const pNoBackslash = p.replace(/\\*/g, "");
+      return value.split(pNoBackslash);
+    }
+  }
+  return null;
+}
+
+/**
+ * Check whether the value string represents something that should be
+ * displayed as text. If so then it shouldn't be parsed into a tree.
+ *
+ * @param  {String} value
+ *         The value to be parsed.
+ */
+function _shouldParse(value) {
+  const validators = [
+    "isBase64",
+    "isBoolean",
+    "isCurrency",
+    "isDataURI",
+    "isEmail",
+    "isFQDN",
+    "isHexColor",
+    "isIP",
+    "isISO8601",
+    "isMACAddress",
+    "isSemVer",
+    "isURL",
+  ];
+
+  // Check for minus calculations e.g. 8-3 because otherwise 5 will be displayed.
+  if (MATH_REGEX.test(value)) {
+    return false;
+  }
+
+  // Check for any other types that shouldn't be parsed.
+  for (const test of validators) {
+    if (validator[test](value)) {
+      return false;
+    }
+  }
+
+  // Seems like this is data that should be parsed.
+  return true;
+}
+
+/**
+ * Tries to parse a string value into either a json or a key-value separated
+ * object. The value can also be a key separated array.
+ *
+ * @param {string} name
+ *        The key corresponding to the `value` string in the object
+ * @param {string} originalValue
+ *        The string to be parsed into an object
+ */
+function parseItemValue(name, originalValue) {
+  // Find if value is URLEncoded ie
+  let decodedValue = "";
+  try {
+    decodedValue = decodeURIComponent(originalValue);
+  } catch (e) {
+    // Unable to decode, nothing to do
+  }
+  const value = (decodedValue && decodedValue !== originalValue)
+    ? decodedValue : originalValue;
+
+  if (!_shouldParse(value)) {
+    return value;
+  }
+
+  let obj = null;
+  try {
+    obj = JSOL.parse(value);
+  } catch (ex) {
+    obj = null;
+  }
+
+  if (!obj && value) {
+    obj = _extractKeyValPairs(value);
+  }
+
+  // return if obj is null, or same as value, or just a string.
+  if (!obj || obj === value || typeof obj === "string") {
+    return value;
+  }
+
+  // If we got this far, originalValue is an object literal or array,
+  // and we have successfully parsed it
+  return obj;
+}
+
+exports.parseItemValue = parseItemValue;
diff --git a/devtools/client/shared/vendor/jsol.js b/devtools/shared/storage/vendor/jsol.js
rename from devtools/client/shared/vendor/jsol.js
rename to devtools/shared/storage/vendor/jsol.js
diff --git a/devtools/shared/storage/vendor/moz.build b/devtools/shared/storage/vendor/moz.build
new file mode 100644
--- /dev/null
+++ b/devtools/shared/storage/vendor/moz.build
@@ -0,0 +1,13 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DIRS += [
+    'stringvalidator',
+]
+
+DevToolsModules(
+    'jsol.js',
+)
diff --git a/devtools/client/shared/vendor/stringvalidator/UPDATING.md b/devtools/shared/storage/vendor/stringvalidator/UPDATING.md
rename from devtools/client/shared/vendor/stringvalidator/UPDATING.md
rename to devtools/shared/storage/vendor/stringvalidator/UPDATING.md
diff --git a/devtools/client/shared/vendor/stringvalidator/moz.build b/devtools/shared/storage/vendor/stringvalidator/moz.build
rename from devtools/client/shared/vendor/stringvalidator/moz.build
rename to devtools/shared/storage/vendor/stringvalidator/moz.build
diff --git a/devtools/client/shared/vendor/stringvalidator/tests/unit/head_stringvalidator.js b/devtools/shared/storage/vendor/stringvalidator/tests/unit/head_stringvalidator.js
rename from devtools/client/shared/vendor/stringvalidator/tests/unit/head_stringvalidator.js
rename to devtools/shared/storage/vendor/stringvalidator/tests/unit/head_stringvalidator.js
diff --git a/devtools/client/shared/vendor/stringvalidator/tests/unit/test_sanitizers.js b/devtools/shared/storage/vendor/stringvalidator/tests/unit/test_sanitizers.js
rename from devtools/client/shared/vendor/stringvalidator/tests/unit/test_sanitizers.js
rename to devtools/shared/storage/vendor/stringvalidator/tests/unit/test_sanitizers.js
diff --git a/devtools/client/shared/vendor/stringvalidator/tests/unit/test_validators.js b/devtools/shared/storage/vendor/stringvalidator/tests/unit/test_validators.js
rename from devtools/client/shared/vendor/stringvalidator/tests/unit/test_validators.js
rename to devtools/shared/storage/vendor/stringvalidator/tests/unit/test_validators.js
diff --git a/devtools/client/shared/vendor/stringvalidator/tests/unit/xpcshell.ini b/devtools/shared/storage/vendor/stringvalidator/tests/unit/xpcshell.ini
rename from devtools/client/shared/vendor/stringvalidator/tests/unit/xpcshell.ini
rename to devtools/shared/storage/vendor/stringvalidator/tests/unit/xpcshell.ini
diff --git a/devtools/client/shared/vendor/stringvalidator/util/assert.js b/devtools/shared/storage/vendor/stringvalidator/util/assert.js
rename from devtools/client/shared/vendor/stringvalidator/util/assert.js
rename to devtools/shared/storage/vendor/stringvalidator/util/assert.js
diff --git a/devtools/client/shared/vendor/stringvalidator/util/moz.build b/devtools/shared/storage/vendor/stringvalidator/util/moz.build
rename from devtools/client/shared/vendor/stringvalidator/util/moz.build
rename to devtools/shared/storage/vendor/stringvalidator/util/moz.build
diff --git a/devtools/client/shared/vendor/stringvalidator/validator.js b/devtools/shared/storage/vendor/stringvalidator/validator.js
rename from devtools/client/shared/vendor/stringvalidator/validator.js
rename to devtools/shared/storage/vendor/stringvalidator/validator.js
diff --git a/toolkit/components/extensions/ExtensionStorageIDB.jsm b/toolkit/components/extensions/ExtensionStorageIDB.jsm
--- a/toolkit/components/extensions/ExtensionStorageIDB.jsm
+++ b/toolkit/components/extensions/ExtensionStorageIDB.jsm
@@ -599,6 +599,11 @@ this.ExtensionStorageIDB = {
         const serializedPrincipal = new StructuredCloneHolder(storagePrincipal, this);
 
         promise = migrateJSONFileData(extension, storagePrincipal).then(() => {
+          extension.setSharedData("storageIDBBackend", true);
+          if (storagePrincipal) {
+            extension.setSharedData("storageIDBPrincipal", storagePrincipal);
+          }
+          Services.ppmm.sharedData.flush();
           return {backendEnabled: true, storagePrincipal: serializedPrincipal};
         }).catch(err => {
           // If the data migration promise is rejected, the old data has been read
@@ -612,6 +617,9 @@ this.ExtensionStorageIDB = {
           // data about it may be useful.
           extension.logWarning("JSONFile backend is being kept enabled by an unexpected " +
                                `IDBBackend failure: ${err.message}::${err.stack}`);
+          extension.setSharedData("storageIDBBackend", false);
+          Services.ppmm.sharedData.flush();
+
           return {backendEnabled: false};
         });
       }
diff --git a/toolkit/components/extensions/parent/ext-storage.js b/toolkit/components/extensions/parent/ext-storage.js
--- a/toolkit/components/extensions/parent/ext-storage.js
+++ b/toolkit/components/extensions/parent/ext-storage.js
@@ -8,6 +8,8 @@ XPCOMUtils.defineLazyModuleGetters(this,
   NativeManifests: "resource://gre/modules/NativeManifests.jsm",
 });
 
+var {ExtensionParent} = ChromeUtils.import("resource://gre/modules/ExtensionParent.jsm");
+
 var {
   ExtensionError,
 } = ExtensionUtils;
@@ -37,6 +39,21 @@ const lookupManagedStorage = async (exte
   return null;
 };
 
+// Notify storage actor when storage data has changed if the extension is targeted
+// by a developer toolbox.
+function notifyDevToolsListeners(extension, changes) {
+  const {DebugUtils} = ExtensionParent;
+  let debugBrowserPromise = DebugUtils.debugBrowserPromises.get(extension.id);
+  if (debugBrowserPromise) {
+    (async () => {
+      const browser = await debugBrowserPromise;
+      browser.messageManager.sendAsyncMessage(
+        `Extension:DevTools:OnStorageLocalChanged`,
+        {changes, extensionUUID: extension.uuid});
+    })();
+  }
+}
+
 this.storage = class extends ExtensionAPI {
   constructor(extension) {
     super(extension);
@@ -82,6 +99,7 @@ this.storage = class extends ExtensionAP
             const changes = await db[method](...args);
             if (changes) {
               ExtensionStorageIDB.notifyListeners(extension.id, changes);
+              notifyDevToolsListeners(extension, changes);
             }
             return changes;
           },
