# HG changeset patch
# User Bianca Danforth <bdanforth@mozilla.com>
# Date 1553039428 25200
#      Tue Mar 19 16:50:28 2019 -0700
# Node ID ff15d6cde8d7f7382800f6ee0669dcdead99e460
# Parent  16d953cca41483b114d70a3132fbcfe60755708f
Bug 1292234 - Prototype extension storage in addon developer toolbox

diff --git a/devtools/server/actors/storage.js b/devtools/server/actors/storage.js
--- a/devtools/server/actors/storage.js
+++ b/devtools/server/actors/storage.js
@@ -12,12 +12,16 @@ const Services = require("Services");
 const defer = require("devtools/shared/defer");
 const {isWindowIncluded} = require("devtools/shared/layout/utils");
 const specs = require("devtools/shared/specs/storage");
+const {ExtensionProcessScript} = require("resource://gre/modules/ExtensionProcessScript.jsm");
+const {ExtensionStorageIDB} = require("resource://gre/modules/ExtensionStorageIDB.jsm");
 
 const CHROME_ENABLED_PREF = "devtools.chrome.enabled";
 const REMOTE_ENABLED_PREF = "devtools.debugger.remote-enabled";
 
 const DEFAULT_VALUE = "value";
 
+const DEVTOOLS_EXT_STORAGELOCAL_CHANGED = "Extension:DevTools:OnStorageLocalChanged";
+
 loader.lazyRequireGetter(this, "naturalSortCaseInsensitive",
   "devtools/client/shared/natural-sort", true);
 
@@ -1298,6 +1302,428 @@ StorageActors.createActor({
   observationTopics: ["dom-storage2-changed", "dom-private-storage2-changed"],
 }, getObjectForLocalOrSessionStorage("sessionStorage"));
 
+const extensionStorageHelpers = {
+  unresolvedPromises: new Map(),
+
+  // Sets the parent process message manager
+  setPpmm(ppmm) {
+    this.ppmm = ppmm;
+  },
+
+  // A promise in the main process has resolved, and we need to pass the return value(s)
+  // back to the child process
+  backToChild(...args) {
+    Services.mm.broadcastAsyncMessage("debug:storage-extensionStorage-request-child", {
+      method: "backToChild",
+      args: args,
+    });
+  },
+
+  // The main process does not require an extension context to select the backend
+  async selectBackendInParent(addonId) {
+    const {WebExtensionPolicy} = Cu.getGlobalForObject(require("resource://gre/modules/XPCOMUtils.jsm"));
+    const {extension} = WebExtensionPolicy.getByID(addonId);
+    const parentResult = await ExtensionStorageIDB.selectBackend({extension});
+    const result = {
+      ...parentResult,
+      // We have to deserialize the result here before sending it back to the
+      // child process, otherwise we get the StructuredCloneHolder object for
+      // storagePrincipal instead
+      storagePrincipal: parentResult.storagePrincipal.deserialize(this, true),
+    };
+    return this.backToChild("selectBackendInParent", result);
+  },
+
+  // Runs in the main process. This determines what code to execute based on the message
+  // received from the child process.
+  async handleChildRequest(msg) {
+    switch (msg.json.method) {
+      case "selectBackendInParent": {
+        const addonId = msg.data.args[0];
+        const result = await extensionStorageHelpers.selectBackendInParent(addonId);
+        return result;
+      }
+      default:
+        console.error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD", msg.json.method);
+        throw new Error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD");
+    }
+  },
+  // Runs in the child process. This determines what code to execute based on the message
+  // received from the parent process.
+  handleParentRequest(msg) {
+    switch (msg.json.method) {
+      case "backToChild": {
+        const [func, rv] = msg.json.args;
+        const deferred = this.unresolvedPromises.get(func);
+        if (deferred) {
+          this.unresolvedPromises.delete(func);
+          deferred.resolve(rv);
+        }
+        break;
+      }
+      default:
+        console.error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD", msg.json.method);
+        throw new Error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD");
+    }
+  },
+  callParentProcessAsync(methodName, ...args) {
+    const deferred = defer();
+
+    this.unresolvedPromises.set(methodName, deferred);
+
+    this.ppmm.sendAsyncMessage("debug:storage-extensionStorage-request-parent", {
+      method: methodName,
+      args: args,
+    });
+
+    return deferred.promise;
+  },
+};
+
+/**
+ * E10S parent/child setup helpers
+ * Add a message listener in the parent process to receive messages from the child
+ * process.
+ */
+exports.setupParentProcessForExtensionStorage = function({mm, prefix}) {
+  // listen for director-script requests from the child process
+  setMessageManager(mm);
+
+  function setMessageManager(newMM) {
+    if (mm) {
+      mm.removeMessageListener("debug:storage-extensionStorage-request-parent",
+                               extensionStorageHelpers.handleChildRequest);
+    }
+    mm = newMM;
+    if (mm) {
+      mm.addMessageListener("debug:storage-extensionStorage-request-parent",
+                            extensionStorageHelpers.handleChildRequest);
+    }
+  }
+
+  return {
+    onBrowserSwap: setMessageManager,
+    onDisconnected: () => {
+      // Although "disconnected-from-child" implies that the child is already
+      // disconnected this is not the case. The disconnection takes place after
+      // this method has finished. This gives us chance to clean up items within
+      // the parent process e.g. observers.
+      setMessageManager(null);
+    },
+  };
+};
+
+/**
+* The Extension Storage actor.
+*/
+StorageActors.createActor({
+  typeName: "extensionStorage",
+}, {
+  initialize(storageActor) {
+    protocol.Actor.prototype.initialize.call(this, null);
+
+    this.storageActor = storageActor;
+
+    this.addonId = this.storageActor.parentActor.addonId;
+
+    // Map<host, ExtensionStorageIDB db connection>
+    this.dbConnectionForHost = new Map();
+
+    this.setupChildProcess();
+
+    this.onStorageChange = this.onStorageChange.bind(this);
+
+    this.conn.parentMessageManager.addMessageListener(
+      DEVTOOLS_EXT_STORAGELOCAL_CHANGED, this.onStorageChange);
+
+    this.populateStoresForHosts();
+
+    this.onWindowReady = this.onWindowReady.bind(this);
+    this.onWindowDestroyed = this.onWindowDestroyed.bind(this);
+    this.storageActor.on("window-ready", this.onWindowReady);
+    this.storageActor.on("window-destroyed", this.onWindowDestroyed);
+  },
+
+  destroy() {
+    this.conn.parentMessageManager.removeMessageListener(
+      DEVTOOLS_EXT_STORAGELOCAL_CHANGED, this.onStorageChange);
+
+    this.storageActor.off("window-ready", this.onWindowReady);
+    this.storageActor.off("window-destroyed", this.onWindowDestroyed);
+
+    this.hostVsStores.clear();
+
+    protocol.Actor.prototype.destroy.call(this);
+
+    this.storageActor = null;
+  },
+
+  setupChildProcess() {
+    const ppmm = this.conn.parentMessageManager;
+    extensionStorageHelpers.setPpmm(ppmm);
+
+    this.conn.setupInParent({
+      module: "devtools/server/actors/storage",
+      setupParent: "setupParentProcessForExtensionStorage",
+    });
+
+    this.selectBackendInParent =
+      extensionStorageHelpers.callParentProcessAsync.bind(
+        extensionStorageHelpers,
+        "selectBackendInParent"
+      );
+
+    // Add a message listener in the child process to receive messages from the parent
+    // process
+    ppmm.addMessageListener(
+      "debug:storage-extensionStorage-request-child",
+      extensionStorageHelpers.handleParentRequest.bind(extensionStorageHelpers),
+    );
+  },
+
+  /**
+  * This fires when the extension changes storage data while the storage
+  * inspector is open. Ensures this.hostVsStores stays up-to-date and
+  * passes the change on to update the view.
+  */
+  onStorageChange({name, data}) {
+    const host = `moz-extension://${data.extensionUUID}`;
+    const changes = data.changes;
+    const storeMap = this.hostVsStores.get(host);
+    if (!storeMap) {
+      return;
+    }
+
+    for (const key in changes) {
+      const storageChange = changes[key];
+      const {newValue, oldValue} = storageChange;
+
+      let action;
+      if (typeof newValue === "undefined") {
+        action = "deleted";
+        storeMap.delete(key);
+      } else if (typeof oldValue === "undefined") {
+        action = "added";
+        storeMap.set(key, newValue);
+      } else {
+        action = "changed";
+        storeMap.set(key, newValue);
+      }
+
+      this.storageActor.update(action, this.typeName, {[host]: [key]});
+    }
+  },
+
+  /**
+   * Purpose of this method is same as populateStoresForHosts but this is async.
+   * This exact same operation cannot be performed in populateStoresForHosts
+   * method, as that method is called in initialize method of the actor, which
+   * cannot be asynchronous.
+   */
+  async preListStores() {
+    this.hostVsStores = new Map();
+
+    for (const window of this.windows) {
+      let host = this.getHostName(window.location);
+      if (!host) {
+        const extension = ExtensionProcessScript.getExtensionChild(this.addonId);
+        host = `moz-extension://${extension.uuid}`;
+      }
+      await this.populateStoresForHost(host, window);
+    }
+  },
+
+  /**
+   * This method is overriden and left blank as for extensionStorage, this operation
+   * cannot be performed synchronously. Thus, the preListStores method exists to
+   * do the same task asynchronously.
+   */
+  populateStoresForHosts() {},
+
+  /**
+  * This method asynchronously reads the browser.storage.local data for the target
+  * extension if it has the storage permission and caches this data into
+  * this.hostVsStores.
+  * @param {String} host - the hostname for the extension
+  */
+  async populateStoresForHost(host) {
+    if (this.hostVsStores.has(host)) {
+      return;
+    }
+
+    const extension = ExtensionProcessScript.getExtensionChild(this.addonId);
+    if (!extension || !(extension.hasPermission("storage"))) {
+      return;
+    }
+
+    const storagePrincipal = await this.getStoragePrincipal(extension);
+
+    if (!storagePrincipal) {
+      return;
+    }
+
+    const db = await ExtensionStorageIDB.open(storagePrincipal);
+    this.dbConnectionForHost.set(host, db);
+    const data = await db.get();
+
+    const storeMap = new Map();
+    for (const [key, value] of Object.entries(data)) {
+      storeMap.set(key, value);
+    }
+
+    this.hostVsStores.set(host, storeMap);
+
+    // Show the storage actor in the add-on storage inspector even when there
+    // is no extension page currently open
+    const storageData = {};
+    storageData[host] = this.getNamesForHost(host);
+    this.storageActor.update("added", this.typeName, storageData);
+  },
+
+  async getStoragePrincipal(extension) {
+    if (extension.getSharedData("storageIDBBackend")) {
+      return extension.getSharedData("storageIDBPrincipal");
+    }
+    // This extension either isn't using the IDB backend (false) or
+    // it hasn't migrated to the IDB backend yet (null)
+    let result;
+
+    // Loop for web extension context related to the current window
+    let currentContext;
+    for (const view of extension.views) {
+      currentContext = view;
+    }
+    if (!currentContext) {
+      // We didn't find the extension context for the current target.
+      // E.g. the extension does not have a background page.
+      // Obtain the storage principal from the main process, which does not require
+      // a context object
+      result = await this.selectBackendInParent(this.addonId);
+    } else {
+      result = await ExtensionStorageIDB.selectBackend(currentContext);
+    }
+
+    const {backendEnabled, storagePrincipal} = result;
+
+    if (!backendEnabled) {
+      // IDB backend disabled; give up.
+      return null;
+    }
+    return storagePrincipal;
+  },
+
+  getValuesForHost(host, name) {
+    const result = [];
+
+    if (!this.hostVsStores.has(host)) {
+      return result;
+    }
+
+    if (name) {
+      return [{name, value: this.hostVsStores.get(host).get(name)}];
+    }
+
+    for (const [key, value] of Array.from(this.hostVsStores.get(host).entries())) {
+      result.push({name: key, value});
+    }
+    return result;
+  },
+
+  /**
+   * This method converts the values returned by getValuesForHost into a StoreObject
+   * (currently based off of this same method for IndexedDB).
+   */
+  toStoreObject({name, value}) {
+    if (!{name, value}) {
+      return null;
+    }
+
+    // Stringify adds redundant quotes to strings
+    if (typeof value !== "string") {
+      // Not all possible values are stringifiable (e.g. functions)
+      value = JSON.stringify(value) || "Object";
+    }
+
+    // FIXME: Bug 1318029 - Due to a bug that is thrown whenever a
+    // LongStringActor string reaches DebuggerServer.LONG_STRING_LENGTH we need
+    // to trim the value. When the bug is fixed we should stop trimming the
+    // string here.
+    const maxLength = DebuggerServer.LONG_STRING_LENGTH - 1;
+    if (value.length > maxLength) {
+      value = value.substr(0, maxLength);
+    }
+
+    return {
+      name,
+      value: new LongStringActor(this.conn, value || ""),
+    };
+  },
+
+  getFields() {
+    return [
+      // name needs to be editable for the addItem case, where a temporary key-value
+      // pair is created that can later be edited via editItem.
+      { name: "name", editable: true },
+      { name: "value", editable: true },
+    ];
+  },
+
+  async addItem(guid, host) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+    const changes = await db.set({[guid]: DEFAULT_VALUE});
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async editItem({host, field, items, oldValue}) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const {name, value} = items;
+    // If the name changed, remove the previous entry in storage by the old name first
+    if (field === "name") {
+      const changes = await db.remove(oldValue);
+      this.fireOnChangedExtensionEvent(host, changes);
+    }
+    const changes = await db.set({[name]: value});
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async removeItem(host, name) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const changes = await db.remove(name);
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async removeAll(host) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const changes = await db.clear();
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  /**
+  * Let the extension know that storage data has been changed by the user from
+  * the storage inspector.
+  */
+  fireOnChangedExtensionEvent(host, changes) {
+    const uuid = (new URL(host)).host;
+    Services.cpmm.sendAsyncMessage(`Extension:StorageLocalOnChanged:${uuid}`,
+                                   changes);
+  },
+});
+
 StorageActors.createActor({
   typeName: "Cache",
 }, {
diff --git a/devtools/server/tests/browser/browser.ini b/devtools/server/tests/browser/browser.ini
--- a/devtools/server/tests/browser/browser.ini
+++ b/devtools/server/tests/browser/browser.ini
@@ -125,6 +125,7 @@ skip-if = e10s # Bug 1183605 - devtools/
 [browser_storage_listings.js]
 [browser_storage_updates.js]
 skip-if = (verify && debug && (os == 'mac' || os == 'linux'))
+[browser_storage_webext_storage_local.js]
 [browser_stylesheets_getTextEmpty.js]
 [browser_stylesheets_nested-iframes.js]
 [browser_register_actor.js]
diff --git a/devtools/server/tests/browser/browser_storage_webext_storage_local.js b/devtools/server/tests/browser/browser_storage_webext_storage_local.js
new file mode 100644
--- /dev/null
+++ b/devtools/server/tests/browser/browser_storage_webext_storage_local.js
@@ -0,0 +1,336 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/* globals browser */
+
+"use strict";
+
+/**
+* This test verifies that web extension local storage (i.e. `browser.storage.local`)
+* data is correctly synced between the `about:debugging` toolbox's Storage panel and a
+* test extension.
+*/
+
+const {Toolbox} = require("devtools/client/framework/toolbox");
+
+/**
+* Starts up and connects the Debugger server to the DevTools client (both in the main
+* process) by listening over an nsIPipe, so that they can send remote debugging
+* protocol messages to each other.
+* @return {Promise} Resolves with a client object when the debugger has started up.
+*/
+async function startDebugger() {
+  initDebuggerServer();
+  const transport = DebuggerServer.connectPipe();
+  const client = new DebuggerClient(transport);
+  await client.connect();
+  return client;
+}
+
+/**
+* Set up and optionally open the `about:debugging` toolbox for a given extension.
+* @param {String} extensionId - The id for the extension to be targeted by the toolbox.
+* @param {Object} options - Configuration options with various optional fields:
+*   - {Boolean} openToolbox - If true, open the toolbox
+* @return {Promise} Resolves with a web extension actor front and target objects and a
+* toolbox object when the toolbox has been setup
+*/
+async function setupExtensionDebuggingToolbox(extensionId, options = {}) {
+  const {openToolbox = false} = options;
+
+  const client = await startDebugger();
+  const front = await client.mainRoot.getAddon({id: extensionId});
+  // Starts a DevTools server in the extension child process.
+  const target = await front.connect(); // JSON representation of the actor
+
+  const toolbox = openToolbox ?
+    await gDevTools.showToolbox(target, null, Toolbox.HostType.WINDOW) : null;
+
+  return {front, target, toolbox};
+}
+
+/**
+* Builds the extension configuration object passed into ExtensionTestUtils.loadExtension
+* @param {Object} - Options, if any, to add to the configuration
+* @param {Function} options.background - A function comprising the test extension's
+* background script if provided
+* @param {Object} options.files - An object whose keys correspond to file names and
+* values map to the file contents
+* @return {Object} - The extension configuration object
+*/
+function getExtensionConfig({background, files} = {}) {
+  const baseConfig = {
+    manifest: {
+      permissions: ["storage"],
+    },
+    useAddonManager: "temporary",
+  };
+  // TODO: This is ugly and hard to follow; consider a switch statement or other approach
+  if (!background && !files) {
+    return baseConfig;
+  } else if (files) {
+    return {
+      files,
+      ...baseConfig,
+    };
+  } else if (background) {
+    return {
+      background,
+      ...baseConfig,
+    };
+  }
+  return {
+    background,
+    files,
+    ...baseConfig,
+  };
+}
+
+/**
+* Gets the extensionStorage store object from the storage actor in the extension process
+* for the target extension
+* @param {Object} target
+* @return {Promise} Resolves with an extensionStorage store object else null when all
+* stores have been obtained
+*/
+async function getExtensionStorage(target) {
+  const storageFront = await target.getFront("storage");
+  const stores = await storageFront.listStores();
+  return (stores.extensionStorage || null);
+}
+
+/**
+* Shutdown procedure common to all tasks.
+* @param {Object} extension - The test extension
+* @param {Object} target - The web extension actor targeted by the DevTools client
+*/
+async function shutdown(extension, target) {
+  await target.destroy();
+  await extension.unload();
+}
+
+add_task(async function test_extension_store_exists() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig());
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  const extensionStorage = await getExtensionStorage(target);
+  ok(extensionStorage, "Should have an extensionStorage store");
+
+  await shutdown(extension, target);
+});
+
+add_task(async function test_extension_origin_matches_debugger_target() {
+  async function background() {
+    browser.test.sendMessage("extension-origin", window.location.origin);
+  }
+
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background})
+  );
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  const {hosts} = await getExtensionStorage(target);
+  const expectedHost = await extension.awaitMessage("extension-origin");
+  ok(expectedHost in hosts,
+     "Should have the expected extension host in the extensionStorage store");
+
+  await shutdown(extension, target);
+});
+
+add_task(async function test_local_storage_update() {
+  async function background() {
+    browser.test.onMessage.addListener(async (msg, ...args) => {
+      switch (msg) {
+        case "storage-local-set":
+          await browser.storage.local.set(args[0]);
+          break;
+        default:
+          browser.test.fail(`Unexpected test message: ${msg}`);
+      }
+
+      browser.test.sendMessage(`${msg}:done`);
+    });
+
+    browser.test.sendMessage("extension-origin", window.location.origin);
+  }
+
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background})
+  );
+
+  await extension.startup();
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  // Don't destructure getStoreObjects here, else 'this' binding fails when it's called
+  const extensionStorage = await getExtensionStorage(target);
+
+  let {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(data, [], "Got the expected results on empty storage.local");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  data = (await extensionStorage.getStoreObjects(host)).data;
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [{name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
+
+/**
+* Storage updates should work correctly if an extension has no background script, but
+* adds storage items via some other transient script, like from an extension page in a tab
+*
+* Test case: Load extension with no background page. Open an extension page in a tab that
+* adds local storage items. With the extension page still open, open the add-on inspector.
+* The data in the inspector should match the items added by the extension.
+*/
+add_task(async function test_local_storage_no_background_script_ext_page_open() {
+  async function extension_page_in_tab() {
+    // TODO: This message listener code is virtually identical to that in the task above
+    // for my background script. Make DRYer
+    browser.test.onMessage.addListener(async (msg, ...args) => {
+      switch (msg) {
+        case "storage-local-set":
+          await browser.storage.local.set(args[0]);
+          break;
+        default:
+          browser.test.fail(`Unexpected test message: ${msg}`);
+      }
+      browser.test.sendMessage(`${msg}:done`);
+    });
+    window.onload = () => {
+      browser.test.sendMessage("extension-origin", window.location.origin);
+    };
+  }
+
+  const files = {
+    "extension_page_in_tab.html": `<!DOCTYPE html>
+      <html>
+        <head>
+          <meta charset="utf-8">
+        </head>
+        <body>
+          <h1>Extension Page in a Tab</h1>
+          <script src="extension_page_in_tab.js"></script>
+        </body>
+      </html>`,
+    "extension_page_in_tab.js": extension_page_in_tab,
+  };
+
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig({files}));
+
+  await extension.startup();
+
+  const url = `moz-extension://${extension.uuid}/extension_page_in_tab.html`;
+  BrowserTestUtils.addTab(gBrowser, url);
+
+  // TODO add info("statement about milestones in each test") in places as helpful
+  // e.g. https://searchfox.org/mozilla-central/source/browser/components/extensions/test/browser/browser_ext_browserAction_popup.js#139
+  const host = await extension.awaitMessage("extension-origin");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  info("Waiting for addon toolbox storage inspector to open");
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  const extensionStorage = await getExtensionStorage(target);
+
+  // Don't destructure getStoreObjects here, else 'this' binding fails when it's called
+  const {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [{name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
+
+/**
+* Storage updates should work correctly if an extension has no background script, but
+* adds storage items via some other transient script, like from an extension page in a tab
+*
+* Test case: Load extension with no background page. Open an extension page in a tab that
+* adds local storage items. Close all extension pages. Open the add-on inspector.
+* The data in the inspector should match the items added by the extension.
+*/
+add_task(async function test_local_storage_no_background_script_no_ext_pages_open() {
+  async function extension_page_in_tab() {
+    // TODO: This message listener code is virtually identical to that in the task above
+    // for my background script. Make DRYer
+    browser.test.onMessage.addListener(async (msg, ...args) => {
+      switch (msg) {
+        case "storage-local-set":
+          await browser.storage.local.set(args[0]);
+          break;
+        default:
+          browser.test.fail(`Unexpected test message: ${msg}`);
+      }
+      browser.test.sendMessage(`${msg}:done`);
+    });
+    window.onload = () => {
+      browser.test.sendMessage("extension-origin", window.location.origin);
+    };
+  }
+  const files = {
+    "extension_page_in_tab.html": `<!DOCTYPE html>
+      <html>
+        <head>
+          <meta charset="utf-8">
+        </head>
+        <body>
+          <h1>Extension Page in a Tab</h1>
+          <script src="extension_page_in_tab.js"></script>
+        </body>
+      </html>`,
+    "extension_page_in_tab.js": extension_page_in_tab,
+  };
+
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig({files}));
+
+  await extension.startup();
+
+  const url = `moz-extension://${extension.uuid}/extension_page_in_tab.html`;
+  const tab = BrowserTestUtils.addTab(gBrowser, url);
+
+  // TODO add info("statement about milestones in each test") in places as helpful
+  // e.g. https://searchfox.org/mozilla-central/source/browser/components/extensions/test/browser/browser_ext_browserAction_popup.js#139
+  const host = await extension.awaitMessage("extension-origin");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  // Close the extension page in the tab
+  BrowserTestUtils.removeTab(tab);
+
+  info("Waiting for addon toolbox storage inspector to open");
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  const extensionStorage = await getExtensionStorage(target);
+
+  // Don't destructure getStoreObjects here, else 'this' binding fails when it's called
+  const {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [{name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
diff --git a/devtools/shared/specs/storage.js b/devtools/shared/specs/storage.js
--- a/devtools/shared/specs/storage.js
+++ b/devtools/shared/specs/storage.js
@@ -163,6 +163,40 @@ createStorageSpec({
   methods: storageMethods,
 });
 
+// TODO: create a new storeObjectType, since extension storage is less
+// restrictive than localStorage/sessionStorage and more restrictive than
+// IndexedDB.
+// Extension store object
+types.addDictType("extensionobject", {
+  name: "nullable:string",
+  value: "nullable:longstring",
+});
+
+// Array of Extension Storage store objects
+types.addDictType("extensionstoreobject", {
+  total: "number",
+  offset: "number",
+  data: "array:nullable:extensionobject",
+});
+
+createStorageSpec({
+  typeName: "extensionStorage",
+  storeObjectType: "extensionstoreobject",
+  methods: {
+    // TODO: May want to define storageMethods differently compared to
+    // localStorage and sessionStorage...
+    ...storageMethods,
+    addExtensionStorageListeners: {
+      request: {},
+      response: {},
+    },
+    removeExtensionStorageListeners: {
+      request: {},
+      response: {},
+    },
+  },
+});
+
 types.addDictType("cacheobject", {
   "url": "string",
   "status": "string",
diff --git a/toolkit/components/extensions/parent/ext-storage.js b/toolkit/components/extensions/parent/ext-storage.js
--- a/toolkit/components/extensions/parent/ext-storage.js
+++ b/toolkit/components/extensions/parent/ext-storage.js
@@ -1,5 +1,7 @@
 "use strict";
 
+/* global ExtensionParent */
+
 XPCOMUtils.defineLazyModuleGetters(this, {
   AddonManagerPrivate: "resource://gre/modules/AddonManager.jsm",
   ExtensionStorage: "resource://gre/modules/ExtensionStorage.jsm",
@@ -37,6 +39,21 @@ const lookupManagedStorage = async (exte
   return null;
 };
 
+// Notify storage actor when storage data has changed if the extension is targeted
+// by a developer toolbox.
+function notifyDevToolsListeners(extension, changes) {
+  const {DebugUtils} = ExtensionParent;
+  let debugBrowserPromise = DebugUtils.debugBrowserPromises.get(extension.id);
+  if (debugBrowserPromise) {
+    (async () => {
+      const browser = await debugBrowserPromise;
+      browser.messageManager.sendAsyncMessage(
+        `Extension:DevTools:OnStorageLocalChanged`,
+        {changes, extensionUUID: extension.uuid});
+    })();
+  }
+}
+
 this.storage = class extends ExtensionAPI {
   constructor(extension) {
     super(extension);
@@ -63,6 +80,8 @@ this.storage = class extends ExtensionAP
     }
 
     ExtensionStorageIDB.notifyListeners(this.extension.id, data);
+
+    notifyDevToolsListeners(this.extension, data);
   }
 
   getAPI(context) {
@@ -82,6 +101,7 @@ this.storage = class extends ExtensionAP
             const changes = await db[method](...args);
             if (changes) {
               ExtensionStorageIDB.notifyListeners(extension.id, changes);
+              notifyDevToolsListeners(extension, changes);
             }
             return changes;
           },
