# HG changeset patch
# User Bianca Danforth <bdanforth@mozilla.com>
# Date 1556821965 25200
#      Thu May 02 11:32:45 2019 -0700
# Node ID f6a7dc1a7deb72864949733e10a9aee01de4aaa9
# Parent  dfc513e7e1413158d8d0d6ccf029c4a0b6a0a2ca
Bug 1542035 - Prototype extension local storage in addon developer toolbox

diff --git a/browser/app/profile/firefox.js b/browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js
+++ b/browser/app/profile/firefox.js
@@ -79,6 +79,9 @@ pref("extensions.langpacks.signatures.re
 pref("xpinstall.signatures.required", true);
 pref("xpinstall.signatures.devInfoURL", "https://wiki.mozilla.org/Addons/Extension_Signing");
 
+// Disable extensionStorage storage actor by default
+pref("devtools.storage.extensionStorage.enabled", false);
+
 // Dictionary download preference
 pref("browser.dictionaries.download.url", "https://addons.mozilla.org/%LOCALE%/firefox/language-tools/");
 
diff --git a/devtools/client/locales/en-US/storage.properties b/devtools/client/locales/en-US/storage.properties
--- a/devtools/client/locales/en-US/storage.properties
+++ b/devtools/client/locales/en-US/storage.properties
@@ -31,6 +31,7 @@ tree.labels.localStorage=Local Storage
 tree.labels.sessionStorage=Session Storage
 tree.labels.indexedDB=Indexed DB
 tree.labels.Cache=Cache Storage
+tree.labels.extensionStorage=Extension Storage
 
 # LOCALIZATION NOTE (table.headers.*.*):
 # These strings are the header names of the columns in the Storage Table for
@@ -67,6 +68,10 @@ table.headers.indexedDB.keyPath2=Key Pat
 table.headers.indexedDB.autoIncrement=Auto Increment
 table.headers.indexedDB.indexes=Indexes
 
+table.headers.extensionStorage.area=Storage Area
+table.headers.extensionStorage.name=Key
+table.headers.extensionStorage.value=Value
+
 # LOCALIZATION NOTE (label.expires.session):
 # This string is displayed in the expires column when the cookie is Session
 # Cookie
diff --git a/devtools/client/shared/vendor/moz.build b/devtools/client/shared/vendor/moz.build
--- a/devtools/client/shared/vendor/moz.build
+++ b/devtools/client/shared/vendor/moz.build
@@ -4,15 +4,10 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-DIRS += [
-    'stringvalidator',
-]
-
 DevToolsModules(
     'fluent-react.js',
     'fluent.js',
     'immutable.js',
-    'jsol.js',
     'jszip.js',
     'lodash.js',
     'react-dom-factories.js',
diff --git a/devtools/client/shared/widgets/TableWidget.js b/devtools/client/shared/widgets/TableWidget.js
--- a/devtools/client/shared/widgets/TableWidget.js
+++ b/devtools/client/shared/widgets/TableWidget.js
@@ -59,7 +59,7 @@ Object.defineProperty(this, "EVENTS", {
  *        - cellContextMenuId: ID of a <menupopup> element to be set as a
  *                             context menu of every cell.
  */
-function TableWidget(node, options = {}) {
+function TableWidget(node, options = {}, front) {
   EventEmitter.decorate(this);
 
   this.document = node.ownerDocument;
@@ -92,6 +92,8 @@ function TableWidget(node, options = {})
   this.items = new Map();
   this.columns = new Map();
 
+  this.front = front;
+
   // Setup the column headers context menu to allow users to hide columns at
   // will.
   if (this.removableColumns) {
@@ -246,6 +248,17 @@ TableWidget.prototype = {
     return filter(columns);
   },
 
+  /*
+  * Get the storageFront for the given storage actor type.
+  */
+  async setStorageFront(type) {
+    if (this._editableFieldsEngine) {
+      const stores = await this.front.listStores();
+      const storageFront = stores[type];
+      this._editableFieldsEngine.setStorageFront(storageFront);
+    }
+  },
+
   /**
    * Emit all cell edit events.
    */
@@ -589,13 +602,19 @@ TableWidget.prototype = {
 
     if (this._editableFieldsEngine) {
       this._editableFieldsEngine.selectors = selectors;
+      this._editableFieldsEngine.front = this.front;
+      this._editableFieldsEngine.host = this.host;
     } else {
-      this._editableFieldsEngine = new EditableFieldsEngine({
-        root: this.tbody,
-        onTab: this.onEditorTab,
-        onTriggerEvent: "dblclick",
-        selectors: selectors,
-      });
+      this._editableFieldsEngine = new EditableFieldsEngine(
+        {
+          root: this.tbody,
+          onTab: this.onEditorTab,
+          onTriggerEvent: "dblclick",
+          selectors: selectors,
+          front: this.front,
+          host: this.host,
+        },
+      );
 
       this._editableFieldsEngine.on("change", this.onChange);
       this._editableFieldsEngine.on("destroyed", this.onEditorDestroyed);
@@ -1720,6 +1739,9 @@ function EditableFieldsEngine(options) {
 
   this.onTrigger = this.onTrigger.bind(this);
   this.root.addEventListener(this.onTriggerEvent, this.onTrigger);
+
+  this.front = options.front;
+  this.host = options.host;
 }
 
 EditableFieldsEngine.prototype = {
@@ -1792,17 +1814,29 @@ EditableFieldsEngine.prototype = {
     }
   },
 
+  setStorageFront: function(front) {
+    this.storageFront = front;
+  },
+
   /**
    * Overlay the target node with an edit field.
    *
    * @param  {Node} target
    *         Dom node to be edited.
    */
-  edit: function(target) {
+  edit: async function(target) {
     if (!target) {
       return;
     }
 
+    // Some values are not parsable by the client or server so should not be editable
+    if (this.storageFront && "isEditable" in this.storageFront) {
+      const name = target.getAttribute("data-id");
+      if (!(await this.storageFront.isEditable(this.host, name))) {
+        return;
+      }
+    }
+
     target.scrollIntoView(false);
     target.focus();
 
diff --git a/devtools/client/storage/ui.js b/devtools/client/storage/ui.js
--- a/devtools/client/storage/ui.js
+++ b/devtools/client/storage/ui.js
@@ -8,7 +8,7 @@
 const EventEmitter = require("devtools/shared/event-emitter");
 const {LocalizationHelper, ELLIPSIS} = require("devtools/shared/l10n");
 const KeyShortcuts = require("devtools/client/shared/key-shortcuts");
-const JSOL = require("devtools/client/shared/vendor/jsol");
+const {parseItemValue} = require("devtools/shared/storage/utils");
 const {KeyCodes} = require("devtools/client/shared/keycodes");
 const { getUnicodeHostname } = require("devtools/client/shared/unicode-url");
 
@@ -24,8 +24,6 @@ loader.lazyRequireGetter(this, "TableWid
                          "devtools/client/shared/widgets/TableWidget", true);
 loader.lazyImporter(this, "VariablesView",
                     "resource://devtools/client/shared/widgets/VariablesView.jsm");
-loader.lazyRequireGetter(this, "validator",
-                         "devtools/client/shared/vendor/stringvalidator/validator");
 
 /**
  * Localization convenience methods.
@@ -62,7 +60,6 @@ const COOKIE_KEY_MAP = {
 };
 
 const SAFE_HOSTS_PREFIXES_REGEX = /^(about:|https?:|file:|moz-extension:)/;
-const MATH_REGEX = /(?:(?:^|[-+_*/])(?:\s*-?\d+(\.\d+)?(?:[eE][+-]?\d+)?\s*))+$/;
 
 // Maximum length of item name to show in context menu label - will be
 // trimmed with ellipsis if it's longer.
@@ -99,11 +96,15 @@ class StorageUI {
     this.tree.on("select", this.onHostSelect);
 
     const tableNode = this._panelDoc.getElementById("storage-table");
-    this.table = new TableWidget(tableNode, {
-      emptyText: L10N.getStr("table.emptyText"),
-      highlightUpdated: true,
-      cellContextMenuId: "storage-table-popup",
-    });
+    this.table = new TableWidget(
+      tableNode,
+      {
+        emptyText: L10N.getStr("table.emptyText"),
+        highlightUpdated: true,
+        cellContextMenuId: "storage-table-popup",
+      },
+      this.front,
+    );
 
     this.updateObjectSidebar = this.updateObjectSidebar.bind(this);
     this.table.on(TableWidget.EVENTS.ROW_SELECTED, this.updateObjectSidebar);
@@ -756,7 +757,10 @@ class StorageUI {
       itemVar.setGrip(value);
 
       // May be the item value is a json or a key value pair itself
-      this.parseItemValue(item.name, value);
+      const obj = parseItemValue(value);
+      if (typeof obj === "object") {
+        this.populateSidebar(item.name, obj);
+      }
 
       // By default the item name and value are shown. If this is the only
       // information available, then nothing else is to be displayed.
@@ -789,7 +793,10 @@ class StorageUI {
         }
 
         mainScope.addItem(key, {}, true).setGrip(item[key]);
-        this.parseItemValue(key, item[key]);
+        const obj = parseItemValue(item[key]);
+        if (typeof obj === "object") {
+          this.populateSidebar(item.name, obj);
+        }
       }
     }
 
@@ -825,47 +832,13 @@ class StorageUI {
     return host;
   }
 
-  /**
-   * Tries to parse a string value into either a json or a key-value separated
-   * object and populates the sidebar with the parsed value. The value can also
-   * be a key separated array.
+  /*
+   * Populates the sidebar with a parsed object.
    *
-   * @param {string} name
-   *        The key corresponding to the `value` string in the object
-   * @param {string} originalValue
-   *        The string to be parsed into an object
+   * @param {object} obj - Either a json or a key-value separated object or a
+   * key separated array
    */
-  parseItemValue(name, originalValue) {
-    // Find if value is URLEncoded ie
-    let decodedValue = "";
-    try {
-      decodedValue = decodeURIComponent(originalValue);
-    } catch (e) {
-      // Unable to decode, nothing to do
-    }
-    const value = (decodedValue && decodedValue !== originalValue)
-      ? decodedValue : originalValue;
-
-    if (!this._shouldParse(value)) {
-      return;
-    }
-
-    let obj = null;
-    try {
-      obj = JSOL.parse(value);
-    } catch (ex) {
-      obj = null;
-    }
-
-    if (!obj && value) {
-      obj = this._extractKeyValPairs(value);
-    }
-
-    // return if obj is null, or same as value, or just a string.
-    if (!obj || obj === value || typeof obj === "string") {
-      return;
-    }
-
+  populateSidebar(name, obj) {
     const jsonObject = Object.create(null);
     const view = this.view;
     jsonObject[name] = obj;
@@ -879,97 +852,6 @@ class StorageUI {
   }
 
   /**
-   * Tries to parse a string into an object on the basis of key-value pairs,
-   * separated by various separators. If failed, tries to parse for single
-   * separator separated values to form an array.
-   *
-   * @param {string} value
-   *        The string to be parsed into an object or array
-   */
-  _extractKeyValPairs(value) {
-    const makeObject = (keySep, pairSep) => {
-      const object = {};
-      for (const pair of value.split(pairSep)) {
-        const [key, val] = pair.split(keySep);
-        object[key] = val;
-      }
-      return object;
-    };
-
-    // Possible separators.
-    const separators = ["=", ":", "~", "#", "&", "\\*", ",", "\\."];
-    // Testing for object
-    for (let i = 0; i < separators.length; i++) {
-      const kv = separators[i];
-      for (let j = 0; j < separators.length; j++) {
-        if (i == j) {
-          continue;
-        }
-        const p = separators[j];
-        const word = `[^${kv}${p}]*`;
-        const keyValue = `${word}${kv}${word}`;
-        const keyValueList = `${keyValue}(${p}${keyValue})*`;
-        const regex = new RegExp(`^${keyValueList}$`);
-        if (value.match && value.match(regex) && value.includes(kv) &&
-            (value.includes(p) || value.split(kv).length == 2)) {
-          return makeObject(kv, p);
-        }
-      }
-    }
-    // Testing for array
-    for (const p of separators) {
-      const word = `[^${p}]*`;
-      const wordList = `(${word}${p})+${word}`;
-      const regex = new RegExp(`^${wordList}$`);
-
-      if (regex.test(value)) {
-        const pNoBackslash = p.replace(/\\*/g, "");
-        return value.split(pNoBackslash);
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Check whether the value string represents something that should be
-   * displayed as text. If so then it shouldn't be parsed into a tree.
-   *
-   * @param  {String} value
-   *         The value to be parsed.
-   */
-  _shouldParse(value) {
-    const validators = [
-      "isBase64",
-      "isBoolean",
-      "isCurrency",
-      "isDataURI",
-      "isEmail",
-      "isFQDN",
-      "isHexColor",
-      "isIP",
-      "isISO8601",
-      "isMACAddress",
-      "isSemVer",
-      "isURL",
-    ];
-
-    // Check for minus calculations e.g. 8-3 because otherwise 5 will be displayed.
-    if (MATH_REGEX.test(value)) {
-      return false;
-    }
-
-    // Check for any other types that shouldn't be parsed.
-    for (const test of validators) {
-      if (validator[test](value)) {
-        return false;
-      }
-    }
-
-    // Seems like this is data that should be parsed.
-    return true;
-  }
-
-  /**
    * Select handler for the storage tree. Fetches details of the selected item
    * from the storage details and populates the storage tree.
    *
@@ -990,6 +872,8 @@ class StorageUI {
     this.table.host = host;
     this.table.datatype = type;
 
+    await this.table.setStorageFront(type);
+
     this.updateToolbar();
 
     let names = null;
diff --git a/devtools/server/actors/storage.js b/devtools/server/actors/storage.js
--- a/devtools/server/actors/storage.js
+++ b/devtools/server/actors/storage.js
@@ -12,12 +12,21 @@ const Services = require("Services");
 const defer = require("devtools/shared/defer");
 const {isWindowIncluded} = require("devtools/shared/layout/utils");
 const specs = require("devtools/shared/specs/storage");
+const {parseItemValue} = require("devtools/shared/storage/utils");
+const {ExtensionProcessScript} = require("resource://gre/modules/ExtensionProcessScript.jsm");
+const {ExtensionStorageIDB} = require("resource://gre/modules/ExtensionStorageIDB.jsm");
+const {WebExtensionPolicy} = Cu.getGlobalForObject(require("resource://gre/modules/XPCOMUtils.jsm"));
+
+const lodash = require("devtools/client/shared/vendor/lodash");
 
 const CHROME_ENABLED_PREF = "devtools.chrome.enabled";
 const REMOTE_ENABLED_PREF = "devtools.debugger.remote-enabled";
+const EXTENSION_STORAGE_ENABLED_PREF = "devtools.storage.extensionStorage.enabled";
 
 const DEFAULT_VALUE = "value";
 
+const DEVTOOLS_EXT_STORAGELOCAL_CHANGED = "Extension:DevTools:OnStorageLocalChanged";
+
 loader.lazyRequireGetter(this, "naturalSortCaseInsensitive",
   "devtools/client/shared/natural-sort", true);
 
@@ -1300,6 +1309,566 @@ StorageActors.createActor({
   observationTopics: ["dom-storage2-changed", "dom-private-storage2-changed"],
 }, getObjectForLocalOrSessionStorage("sessionStorage"));
 
+const extensionStorageHelpers = {
+  unresolvedPromises: new Map(),
+  onChangedListeners: new Map(),
+  typesFromString: { // Helper methods to parse string values in editItem
+    jsonifiable: {
+      test(str) {
+        try {
+          JSON.parse(str);
+        } catch (e) {
+          return false;
+        }
+        return true;
+      },
+      parse(str) {
+        return JSON.parse(str);
+      },
+    },
+    bigInt: {
+      test(str) {
+        return /^\d+n{1}$/.test(str);
+      },
+      parse(str) {
+        return BigInt(str.replace("n", ""));
+      },
+    },
+    date: {
+      test(str) {
+        return !isNaN(Date.parse(str));
+      },
+      parse(str) {
+        return new Date(Date.parse(str));
+      },
+    },
+    regexp: {
+      test(str) {
+        if (!/^\/{1}/.test(str)) {
+          return false;
+        }
+        try {
+          new RegExp(str);
+        } catch (e) {
+          return false;
+        }
+        return true;
+      },
+      parse(str) {
+        return new RegExp(str);
+      },
+    },
+  },
+  supportedTypes: { // Helper methods to determine the value type of an item in isEditable
+    isArray: function(value) {
+      return Array.isArray(value);
+    },
+    isBigint: function(value) {
+      // eslint-disable-next-line
+      return typeof value === "bigint";
+    },
+    isBoolean: function(value) {
+      return typeof value === "boolean";
+    },
+    isDate: function(value) {
+      return lodash.isDate(value);
+    },
+    isNull: function(value) {
+      return value === null;
+    },
+    isNumber: function(value) {
+      return typeof value === "number";
+    },
+    isObject: function(value) {
+      return lodash.isPlainObject(value);
+    },
+    isRegexp: function(value) {
+      return lodash.isRegExp(value);
+    },
+    isString: function(value) {
+      return typeof value === "string";
+    },
+    isUndefined: function(value) {
+      return typeof value === "undefined";
+    },
+  },
+
+  // Sets the parent process message manager
+  setPpmm(ppmm) {
+    this.ppmm = ppmm;
+  },
+
+  // A promise in the main process has resolved, and we need to pass the return value(s)
+  // back to the child process
+  backToChild(...args) {
+    Services.mm.broadcastAsyncMessage("debug:storage-extensionStorage-request-child", {
+      method: "backToChild",
+      args: args,
+    });
+  },
+
+  // The main process does not require an extension context to select the backend
+  async selectBackendInParent(addonId) {
+    const {extension} = WebExtensionPolicy.getByID(addonId);
+    const parentResult = await ExtensionStorageIDB.selectBackend({extension});
+    const result = {
+      ...parentResult,
+      // We have to deserialize the result here before sending it back to the
+      // child process, otherwise we get the StructuredCloneHolder object for
+      // storagePrincipal instead
+      storagePrincipal: parentResult.storagePrincipal.deserialize(this, true),
+    };
+
+    // Subscribe a listener for the storage.onChanged API event notifications
+    // and keep track of it to remove it when the debugger is being disconnected.
+    const messageName = `Extension:StorageLocalOnChanged:${extension.uuid}`;
+    const onChangedListener = ({name, data}) => {
+      Services.mm.broadcastAsyncMessage(DEVTOOLS_EXT_STORAGELOCAL_CHANGED, {
+        changes: data,
+        extensionUUID: extension.uuid,
+      });
+    };
+    Services.ppmm.addMessageListener(messageName, onChangedListener);
+    this.onChangedListeners.set(messageName, onChangedListener);
+    return this.backToChild("selectBackendInParent", result);
+  },
+
+  onDisconnected() {
+    // Remove any listener subscribed to intercept storage.onChanged API events.
+    for (const [messageName, listener] of this.onChangedListeners) {
+      Services.ppmm.removeMessageListener(messageName, listener);
+    }
+  },
+
+  // Runs in the main process. This determines what code to execute based on the message
+  // received from the child process.
+  async handleChildRequest(msg) {
+    switch (msg.json.method) {
+      case "selectBackendInParent": {
+        const addonId = msg.data.args[0];
+        const result = await extensionStorageHelpers.selectBackendInParent(addonId);
+        return result;
+      }
+      default:
+        console.error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD", msg.json.method);
+        throw new Error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD");
+    }
+  },
+  // Runs in the child process. This determines what code to execute based on the message
+  // received from the parent process.
+  handleParentRequest(msg) {
+    switch (msg.json.method) {
+      case "backToChild": {
+        const [func, rv] = msg.json.args;
+        const deferred = this.unresolvedPromises.get(func);
+        if (deferred) {
+          this.unresolvedPromises.delete(func);
+          deferred.resolve(rv);
+        }
+        break;
+      }
+      default:
+        console.error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD", msg.json.method);
+        throw new Error("ERR_DIRECTOR_PARENT_UNKNOWN_METHOD");
+    }
+  },
+  callParentProcessAsync(methodName, ...args) {
+    const deferred = defer();
+
+    this.unresolvedPromises.set(methodName, deferred);
+
+    this.ppmm.sendAsyncMessage("debug:storage-extensionStorage-request-parent", {
+      method: methodName,
+      args: args,
+    });
+
+    return deferred.promise;
+  },
+};
+
+/**
+ * E10S parent/child setup helpers
+ * Add a message listener in the parent process to receive messages from the child
+ * process.
+ */
+exports.setupParentProcessForExtensionStorage = function({mm, prefix}) {
+  // listen for director-script requests from the child process
+  setMessageManager(mm);
+
+  function setMessageManager(newMM) {
+    if (mm) {
+      mm.removeMessageListener("debug:storage-extensionStorage-request-parent",
+                               extensionStorageHelpers.handleChildRequest);
+    }
+    mm = newMM;
+    if (mm) {
+      mm.addMessageListener("debug:storage-extensionStorage-request-parent",
+                            extensionStorageHelpers.handleChildRequest);
+    }
+  }
+
+  return {
+    onBrowserSwap: setMessageManager,
+    onDisconnected: () => {
+      // Although "disconnected-from-child" implies that the child is already
+      // disconnected this is not the case. The disconnection takes place after
+      // this method has finished. This gives us chance to clean up items within
+      // the parent process e.g. observers.
+      setMessageManager(null);
+      extensionStorageHelpers.onDisconnected();
+    },
+  };
+};
+
+/**
+* The Extension Storage actor.
+*/
+if (Services.prefs.getBoolPref(EXTENSION_STORAGE_ENABLED_PREF)) {
+  StorageActors.createActor({
+    typeName: "extensionStorage",
+  }, {
+    initialize(storageActor) {
+      protocol.Actor.prototype.initialize.call(this, null);
+
+      this.storageActor = storageActor;
+
+      this.addonId = this.storageActor.parentActor.addonId;
+
+      // Map<host, ExtensionStorageIDB db connection>
+      this.dbConnectionForHost = new Map();
+
+      this.setupChildProcess();
+
+      this.onStorageChange = this.onStorageChange.bind(this);
+
+      this.conn.parentMessageManager.addMessageListener(
+        DEVTOOLS_EXT_STORAGELOCAL_CHANGED, this.onStorageChange);
+
+      this.populateStoresForHosts();
+
+      this.onWindowReady = this.onWindowReady.bind(this);
+      this.onWindowDestroyed = this.onWindowDestroyed.bind(this);
+      this.storageActor.on("window-ready", this.onWindowReady);
+      this.storageActor.on("window-destroyed", this.onWindowDestroyed);
+    },
+
+    destroy() {
+      this.conn.parentMessageManager.removeMessageListener(
+        DEVTOOLS_EXT_STORAGELOCAL_CHANGED, this.onStorageChange);
+
+      this.storageActor.off("window-ready", this.onWindowReady);
+      this.storageActor.off("window-destroyed", this.onWindowDestroyed);
+
+      this.hostVsStores.clear();
+
+      protocol.Actor.prototype.destroy.call(this);
+
+      this.storageActor = null;
+    },
+
+    setupChildProcess() {
+      const ppmm = this.conn.parentMessageManager;
+      extensionStorageHelpers.setPpmm(ppmm);
+
+      this.conn.setupInParent({
+        module: "devtools/server/actors/storage",
+        setupParent: "setupParentProcessForExtensionStorage",
+      });
+
+      this.selectBackendInParent =
+        extensionStorageHelpers.callParentProcessAsync.bind(
+          extensionStorageHelpers,
+          "selectBackendInParent"
+        );
+
+      // Add a message listener in the child process to receive messages from the parent
+      // process
+      ppmm.addMessageListener(
+        "debug:storage-extensionStorage-request-child",
+        extensionStorageHelpers.handleParentRequest.bind(extensionStorageHelpers),
+      );
+    },
+
+    /**
+    * This fires when the extension changes storage data while the storage
+    * inspector is open. Ensures this.hostVsStores stays up-to-date and
+    * passes the change on to update the view.
+    */
+    onStorageChange({name, data}) {
+      const host = `moz-extension://${data.extensionUUID}`;
+      const changes = data.changes;
+      const storeMap = this.hostVsStores.get(host);
+      if (!storeMap) {
+        return;
+      }
+
+      for (const key in changes) {
+        const storageChange = changes[key];
+        let {newValue, oldValue} = storageChange;
+        if (newValue && typeof newValue === "object"
+          && Cu.getClassName(newValue, true) === "StructuredCloneHolder") {
+          newValue = newValue.deserialize(this);
+        }
+        if (oldValue && typeof oldValue === "object"
+          && Cu.getClassName(oldValue, true) === "StructuredCloneHolder") {
+          oldValue = oldValue.deserialize(this);
+        }
+
+        let action;
+        if (this.hostVsStores.get(host).get(key) !== undefined
+          && typeof newValue === "undefined") {
+          action = "deleted";
+          storeMap.delete(key);
+        } else if (this.hostVsStores.get(host).get(key) === undefined
+          && typeof oldValue === "undefined") {
+          action = "added";
+          storeMap.set(key, newValue);
+        } else {
+          action = "changed";
+          storeMap.set(key, newValue);
+        }
+
+        this.storageActor.update(action, this.typeName, {[host]: [key]});
+      }
+    },
+
+    /**
+     * Purpose of this method is same as populateStoresForHosts but this is async.
+     * This exact same operation cannot be performed in populateStoresForHosts
+     * method, as that method is called in initialize method of the actor, which
+     * cannot be asynchronous.
+     */
+    async preListStores() {
+      // Ensure the actor's target is an extension and it is enabled
+      if (!this.addonId || !(WebExtensionPolicy.getByID(this.addonId))) {
+        return;
+      }
+
+      this.hostVsStores = new Map();
+      const extension = ExtensionProcessScript.getExtensionChild(this.addonId);
+      await this.populateStoresForHost(`moz-extension://${extension.uuid}`);
+    },
+
+    /**
+     * This method is overriden and left blank as for extensionStorage, this operation
+     * cannot be performed synchronously. Thus, the preListStores method exists to
+     * do the same task asynchronously.
+     */
+    populateStoresForHosts() {},
+
+    /**
+    * This method asynchronously reads the browser.storage.local data for the target
+    * extension if it has the storage permission and caches this data into
+    * this.hostVsStores.
+    * @param {String} host - the hostname for the extension
+    */
+    async populateStoresForHost(host) {
+      if (this.hostVsStores.has(host)) {
+        return;
+      }
+
+      const extension = ExtensionProcessScript.getExtensionChild(this.addonId);
+      if (!extension || !(extension.hasPermission("storage"))) {
+        return;
+      }
+
+      const storagePrincipal = await this.getStoragePrincipal(extension);
+
+      if (!storagePrincipal) {
+        return;
+      }
+
+      const db = await ExtensionStorageIDB.open(storagePrincipal);
+      this.dbConnectionForHost.set(host, db);
+      const data = await db.get();
+
+      const storeMap = new Map();
+      for (const [key, value] of Object.entries(data)) {
+        storeMap.set(key, value);
+      }
+
+      this.hostVsStores.set(host, storeMap);
+
+      // Show the storage actor in the add-on storage inspector even when there
+      // is no extension page currently open
+      const storageData = {};
+      storageData[host] = this.getNamesForHost(host);
+      this.storageActor.update("added", this.typeName, storageData);
+    },
+
+    async getStoragePrincipal(extension) {
+      const {
+        backendEnabled,
+        storagePrincipal,
+      } = await this.selectBackendInParent(extension.id);
+
+      if (!backendEnabled) {
+        // IDB backend disabled; give up.
+        return null;
+      }
+      return storagePrincipal;
+    },
+
+    getValuesForHost(host, name) {
+      const result = [];
+
+      if (!this.hostVsStores.has(host)) {
+        return result;
+      }
+
+      if (name) {
+        return [{name, value: this.hostVsStores.get(host).get(name)}];
+      }
+
+      for (const [key, value] of Array.from(this.hostVsStores.get(host).entries())) {
+        result.push({name: key, value});
+      }
+      return result;
+    },
+
+    /**
+     * Converts a storage item to an "extensionobject" as defined in
+     * devtools/shared/specs/storage.js
+     * @param {Object} item - The storage item to convert
+     * @param {String} item.name - The storage item key
+     * @param {*} item.value - The storage item value
+     * @return {extensionobject}
+     */
+    toStoreObject(item) {
+      if (!item) {
+        return null;
+      }
+
+      let {name, value} = item;
+
+      if (typeof value !== "string") {
+        if (value instanceof RegExp) {
+          value = value.toSource();
+        } else if (value instanceof Date) {
+          value = value.toJSON();
+        } else {
+          try {
+            value = JSON.stringify(value) || String(value);
+          } catch (error) {
+            // throws for typeof bigint
+            value = value.toString();
+          }
+        }
+      }
+
+      // FIXME: Bug 1318029 - Due to a bug that is thrown whenever a
+      // LongStringActor string reaches DebuggerServer.LONG_STRING_LENGTH we need
+      // to trim the value. When the bug is fixed we should stop trimming the
+      // string here.
+      const maxLength = DebuggerServer.LONG_STRING_LENGTH - 1;
+      if (value.length > maxLength) {
+        value = value.substr(0, maxLength);
+      }
+
+      return {
+        name,
+        value: new LongStringActor(this.conn, value || ""),
+        area: "local",
+      };
+    },
+
+    getFields() {
+      return [
+        // name needs to be editable for the addItem case, where a temporary key-value
+        // pair is created that can later be edited via editItem.
+        { name: "name", editable: true },
+        { name: "value", editable: true },
+        { name: "area", editable: false },
+      ];
+    },
+
+    /**
+    * Editing is supported only for serializable value types. Examples of unserializable
+    * types include Map, Set and ArrayBuffer.
+    */
+    async isEditable(host, name) {
+      const db = this.dbConnectionForHost.get(host);
+      const item = await db.get([name]);
+      const value = item[name];
+      const {supportedTypes} = extensionStorageHelpers;
+      for (const isSupportedType of Object.values(supportedTypes)) {
+        if (isSupportedType(value)) {
+          return true;
+        }
+      }
+      return false;
+    },
+
+    async addItem(guid, host) {
+      const db = this.dbConnectionForHost.get(host);
+      if (!db) {
+        return;
+      }
+      const changes = await db.set({[guid]: DEFAULT_VALUE});
+      this.fireOnChangedExtensionEvent(host, changes);
+    },
+
+    async editItem({host, field, items, oldValue}) {
+      const db = this.dbConnectionForHost.get(host);
+      if (!db) {
+        return;
+      }
+
+      const {name, value} = items;
+      // If the name changed, remove the previous entry in storage by the old name first
+      if (field === "name") {
+        const changes = await db.remove(oldValue);
+        this.fireOnChangedExtensionEvent(host, changes);
+      }
+
+      // Attempt to interpret the data type of the value
+      let parsedValue = parseItemValue(value);
+      if (parsedValue === value) {
+        const {typesFromString} = extensionStorageHelpers;
+        for (const {test, parse} of Object.values(typesFromString)) {
+          if (test(value)) {
+            parsedValue = parse(value);
+            break;
+          }
+        }
+      }
+
+      const changes = await db.set({[name]: parsedValue});
+      this.fireOnChangedExtensionEvent(host, changes);
+    },
+
+    async removeItem(host, name) {
+      const db = this.dbConnectionForHost.get(host);
+      if (!db) {
+        return;
+      }
+
+      const changes = await db.remove(name);
+      this.fireOnChangedExtensionEvent(host, changes);
+    },
+
+    async removeAll(host) {
+      const db = this.dbConnectionForHost.get(host);
+      if (!db) {
+        return;
+      }
+
+      const changes = await db.clear();
+      this.fireOnChangedExtensionEvent(host, changes);
+    },
+
+    /**
+    * Let the extension know that storage data has been changed by the user from
+    * the storage inspector.
+    */
+    fireOnChangedExtensionEvent(host, changes) {
+      const uuid = (new URL(host)).host;
+      Services.cpmm.sendAsyncMessage(`Extension:StorageLocalOnChanged:${uuid}`,
+                                     changes);
+    },
+  });
+}
+
 StorageActors.createActor({
   typeName: "Cache",
 }, {
@@ -2690,9 +3259,12 @@ const StorageActor = protocol.ActorClass
         (!subject.location.href || subject.location.href == "about:blank")) {
       return null;
     }
-
-    if (topic == "content-document-global-created" &&
-        this.isIncludedInTopLevelWindow(subject)) {
+    // We don't want to try to find a top level window for an extension page, as
+    // in many cases (e.g. background page), it is not loaded in a tab, and
+    // 'isIncludedInTopLevelWindow' throws an error
+    if (topic == "content-document-global-created"
+      && (subject.location.href.startsWith("moz-extension://")
+      || this.isIncludedInTopLevelWindow(subject))) {
       this.childWindowPool.add(subject);
       this.emit("window-ready", subject);
     } else if (topic == "inner-window-destroyed") {
@@ -2747,6 +3319,11 @@ const StorageActor = protocol.ActorClass
     const toReturn = {};
 
     for (const [name, value] of this.childActorPool) {
+      // Only list extensionStorage for the add-on storage panel
+      if (name === "extensionStorage"
+        && (!value.storageActor.parentActor.addonId)) {
+        continue;
+      }
       if (value.preListStores) {
         await value.preListStores();
       }
diff --git a/devtools/server/tests/browser/browser.ini b/devtools/server/tests/browser/browser.ini
--- a/devtools/server/tests/browser/browser.ini
+++ b/devtools/server/tests/browser/browser.ini
@@ -127,6 +127,7 @@ skip-if = e10s # Bug 1183605 - devtools/
 [browser_storage_listings.js]
 [browser_storage_updates.js]
 skip-if = (verify && debug && (os == 'mac' || os == 'linux')) || (os == 'win' && debug) # Bug 1493369
+[browser_storage_webext_storage_local.js]
 [browser_stylesheets_getTextEmpty.js]
 [browser_stylesheets_nested-iframes.js]
 [browser_register_actor.js]
diff --git a/devtools/server/tests/browser/browser_storage_webext_storage_local.js b/devtools/server/tests/browser/browser_storage_webext_storage_local.js
new file mode 100644
--- /dev/null
+++ b/devtools/server/tests/browser/browser_storage_webext_storage_local.js
@@ -0,0 +1,32 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+add_task(async function test_extension_store_disabled_for_non_extension_target_process() {
+  // Pref remains in effect until test completes and is automatically cleared afterwards
+  await SpecialPowers.pushPrefEnv({
+    set: [["devtools.storage.extensionStorage.enabled", true]],
+  });
+
+  info("Setting up and connecting Debugger Server and Client in main process");
+  initDebuggerServer();
+  const transport = DebuggerServer.connectPipe();
+  const client = new DebuggerClient(transport);
+  await client.connect();
+
+  info("Opening a non-extension page in a tab");
+  const target = await addTabTarget("data:text/html;charset=utf-8,");
+
+  info("Getting all stores for the target process");
+  const storageFront = await target.getFront("storage");
+  const stores = await storageFront.listStores();
+
+  ok(
+    !("extensionStorage" in stores),
+    "Should not have an extensionStorage store when non-extension process is targeted"
+  );
+
+  target.destroy();
+});
diff --git a/devtools/server/tests/unit/test_extension_storage_actor.js b/devtools/server/tests/unit/test_extension_storage_actor.js
new file mode 100644
--- /dev/null
+++ b/devtools/server/tests/unit/test_extension_storage_actor.js
@@ -0,0 +1,802 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/* globals browser */
+
+"use strict";
+
+const {
+  AddonTestUtils,
+} = ChromeUtils.import("resource://testing-common/AddonTestUtils.jsm");
+
+const {
+  FileUtils,
+} = ChromeUtils.import("resource://gre/modules/FileUtils.jsm");
+
+const {
+  ExtensionTestUtils,
+} = ChromeUtils.import("resource://testing-common/ExtensionXPCShellUtils.jsm");
+
+const {
+  createAppInfo,
+  promiseStartupManager,
+} = AddonTestUtils;
+
+const LEAVE_UUID_PREF = "extensions.webextensions.keepUuidOnUninstall";
+const LEAVE_STORAGE_PREF = "extensions.webextensions.keepStorageOnUninstall";
+const EXTENSION_STORAGE_ENABLED_PREF = "devtools.storage.extensionStorage.enabled";
+
+AddonTestUtils.init(this);
+createAppInfo("xpcshell@tests.mozilla.org", "XPCShell", "1", "42");
+
+ExtensionTestUtils.init(this);
+
+// This storage actor is gated behind a pref, so make sure it is enabled first
+Services.prefs.setBoolPref(EXTENSION_STORAGE_ENABLED_PREF, true);
+registerCleanupFunction(() => {
+  Services.prefs.clearUserPref(EXTENSION_STORAGE_ENABLED_PREF);
+});
+
+/**
+* Starts up and connects the Debugger server to the DevTools client (both in the main
+* process) by listening over an nsIPipe, so that they can send remote debugging
+* protocol messages to each other.
+* @return {Promise} Resolves with a client object when the debugger has started up.
+*/
+async function startDebugger() {
+  DebuggerServer.init();
+  DebuggerServer.registerAllActors();
+  const transport = DebuggerServer.connectPipe();
+  const client = new DebuggerClient(transport);
+  await client.connect();
+  return client;
+}
+
+/**
+* Set up the `about:debugging` toolbox for a given extension.
+* @param {String} extensionId - The id for the extension to be targeted by the toolbox.
+* @return {Promise} Resolves with a web extension actor front and target objects when
+* the toolbox has been setup
+*/
+async function setupExtensionDebugging(extensionId) {
+  const client = await startDebugger();
+  const front = await client.mainRoot.getAddon({id: extensionId});
+  // Starts a DevTools server in the extension child process.
+  const target = await front.connect(); // JSON representation of the actor
+  return {front, target};
+}
+
+/**
+* Builds the extension configuration object passed into ExtensionTestUtils.loadExtension
+* @param {Object} - Options, if any, to add to the configuration
+* @param {Function} options.background - A function comprising the test extension's
+* background script if provided
+* @param {Object} options.files - An object whose keys correspond to file names and
+* values map to the file contents
+* @param {Object} options.manifest - An object representing the extension's manifest
+* @return {Object} - The extension configuration object
+*/
+function getExtensionConfig(options = {}) {
+  const {manifest, ...otherOptions} = options;
+  const baseConfig = {
+    manifest: {
+      ...manifest,
+      permissions: ["storage"],
+    },
+    useAddonManager: "temporary",
+  };
+  return {
+    ...baseConfig,
+    ...otherOptions,
+  };
+}
+
+/**
+* Gets the extensionStorage store object from the storage actor in the extension process
+* for the target extension
+* @param {Object} target
+* @return {Promise} Resolves with an extensionStorage store object else null when all
+* stores have been obtained
+*/
+async function getExtensionStorage(target) {
+  const storageFront = await target.getFront("storage");
+  const stores = await storageFront.listStores();
+  return (stores.extensionStorage || null);
+}
+
+/**
+* Shutdown procedure common to all tasks.
+* @param {Object} extension - The test extension
+* @param {Object} target - The web extension actor targeted by the DevTools client
+*/
+async function shutdown(extension, target) {
+  if (target) {
+    await target.destroy();
+  }
+  await extension.unload();
+}
+
+/**
+* A generic extension script that can be used in any extension context (e.g. a
+* background script or an extension page script loaded in a tab).
+*/
+async function extensionScriptWithMessageListener() {
+  let valType;
+  browser.test.onMessage.addListener(async (msg, ...args) => {
+    switch (msg) {
+      case "storage-local-set":
+        await browser.storage.local.set(args[0]);
+        const item = args[0];
+        valType = typeof item[Object.keys(item)[0]];
+        await browser.storage.local.set(item);
+        break;
+      case "storage-local-get":
+        const {key} = args[0];
+        valType = args[0].valType || valType;
+        const value = (await browser.storage.local.get(key))[key];
+        browser.test.assertTrue(
+          (typeof value === valType),
+          "The data type for the storage item's value is unchanged."
+        );
+        break;
+      default:
+        browser.test.fail(`Unexpected test message: ${msg}`);
+    }
+
+    browser.test.sendMessage(`${msg}:done`);
+  });
+  browser.test.sendMessage("extension-origin", window.location.origin);
+}
+
+/**
+* Shared files for a test extension that has no background page but adds storage
+* items via a transient extension page in a tab
+*/
+const ext_no_bg = {
+  files: {
+    "extension_page_in_tab.html": `<!DOCTYPE html>
+      <html>
+        <head>
+          <meta charset="utf-8">
+        </head>
+        <body>
+          <h1>Extension Page in a Tab</h1>
+          <script src="extension_page_in_tab.js"></script>
+        </body>
+      </html>`,
+    "extension_page_in_tab.js": extensionScriptWithMessageListener,
+  },
+};
+
+/**
+ * Mocks the missing 'storage/permanent' directory needed by the "indexedDB"
+ * storage actor's preListStores method (called when 'listStores' is called). This
+ * directory exists in a full browser i.e. mochitest.
+ */
+function createMissingIndexedDBDirs() {
+  const dir = (Services.dirsvc.get("ProfD", Ci.nsIFile)).clone();
+  dir.append("storage");
+  if (!dir.exists()) {
+    dir.create(dir.DIRECTORY_TYPE, FileUtils.PERMS_DIRECTORY);
+  }
+  dir.append("permanent");
+  if (!dir.exists()) {
+    dir.create(dir.DIRECTORY_TYPE, FileUtils.PERMS_DIRECTORY);
+  }
+  Assert.ok(dir.exists(), "Should have a 'storage/permanent' dir in the profile dir");
+}
+
+add_task(async function setup() {
+  await promiseStartupManager();
+  createMissingIndexedDBDirs();
+});
+
+add_task(async function test_extension_store_exists() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig());
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebugging(extension.id);
+
+  const extensionStorage = await getExtensionStorage(target);
+  ok(extensionStorage, "Should have an extensionStorage store");
+
+  await shutdown(extension, target);
+});
+
+add_task(async function test_extension_origin_matches_debugger_target() {
+  async function background() {
+    browser.test.sendMessage("extension-origin", window.location.origin);
+  }
+
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background})
+  );
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebugging(extension.id);
+  const {hosts} = await getExtensionStorage(target);
+  const expectedHost = await extension.awaitMessage("extension-origin");
+  ok(expectedHost in hosts,
+     "Should have the expected extension host in the extensionStorage store");
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: Bg page adds item while inspector is open.
+* - Load extension with background page.
+* - Open the add-on inspector.
+* - With the inspector still open, add an item from the background page.
+* - The data in the inspector should match the item added by the extension.
+*/
+add_task(async function test_local_storage_live_update() {
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background: extensionScriptWithMessageListener})
+  );
+
+  await extension.startup();
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  const {target} = await setupExtensionDebugging(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  let {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(data, [], "Got the expected results on empty storage.local");
+
+  extension.sendMessage("storage-local-set", {
+    a: 123,
+    b: [4, 5],
+    c: {d: 678},
+    d: true,
+    e: "hi",
+    f: null,
+    g: undefined,
+    h: new Date(0),
+    i: /regexp/,
+    j: 1n,
+  });
+  await extension.awaitMessage("storage-local-set:done");
+
+  data = (await extensionStorage.getStoreObjects(host)).data;
+  Assert.deepEqual(
+    data, [
+      {area: "local", name: "a", value: {str: "123"}},
+      {area: "local", name: "b", value: {str: "[4,5]"}},
+      {area: "local", name: "c", value: {str: "{\"d\":678}"}},
+      {area: "local", name: "d", value: {str: "true"}},
+      {area: "local", name: "e", value: {str: "hi"}},
+      {area: "local", name: "f", value: {str: "null"}},
+      {area: "local", name: "g", value: {str: "undefined"}},
+      {area: "local", name: "h", value: {str: "1970-01-01T00:00:00.000Z"}},
+      {area: "local", name: "i", value: {str: "/regexp/"}},
+      {area: "local", name: "j", value: {str: "1"}},
+    ],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: No bg page. Transient page adds item before inspector opened.
+* - Load extension with no background page.
+* - Open an extension page in a tab that adds a local storage item.
+* - With the extension page still open, open the add-on inspector.
+* - The data in the inspector should match the items added by the extension.
+*/
+add_task(async function test_local_storage_ext_no_bg_with_ext_page_open() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig({
+    files: ext_no_bg.files,
+  }));
+
+  await extension.startup();
+
+  const url = extension.extension.baseURI.resolve("extension_page_in_tab.html");
+  const contentPage = await ExtensionTestUtils.loadContentPage(url, {extension});
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  const {target} = await setupExtensionDebugging(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  const {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    [{area: "local", name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await contentPage.close();
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: No bg page. Transient page adds item, then closes before inspector opened.
+* - Load extension with no background page.
+* - Open an extension page in a tab that adds a local storage item.
+* - Close all extension pages.
+* - Open the add-on inspector.
+* - The data in the inspector should match the item added by the extension.
+*/
+add_task(async function test_local_storage_ext_no_bg_with_no_ext_page_open() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig({
+    files: ext_no_bg.files,
+  }));
+
+  await extension.startup();
+
+  const url = extension.extension.baseURI.resolve("extension_page_in_tab.html");
+  const contentPage = await ExtensionTestUtils.loadContentPage(url, {extension});
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  await contentPage.close();
+
+  const {target} = await setupExtensionDebugging(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  const {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    [{area: "local", name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: No bg page. Inspector live updates when a transient page adds an item.
+* - Load extension with no background page.
+* - Open the add-on storage inspector.
+* - With the inspector still open, open an extension page in a new tab that adds an item.
+* - Assert:
+*   - The data in the inspector should live update to match the item added by the
+*     extension.
+*   - If an extension page adds the same data again, the data in the inspector should
+*     not change.
+*/
+add_task(async function test_local_storage_ext_no_bg_live_update() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig({
+    files: ext_no_bg.files,
+  }));
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebugging(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  const url = extension.extension.baseURI.resolve("extension_page_in_tab.html");
+  const contentPage = await ExtensionTestUtils.loadContentPage(url, {extension});
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  let {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(data, [], "Got the expected results on empty storage.local");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  data = (await extensionStorage.getStoreObjects(host)).data;
+  Assert.deepEqual(
+    data,
+    [{area: "local", name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  data = (await extensionStorage.getStoreObjects(host)).data;
+  Assert.deepEqual(
+    data,
+    [{area: "local", name: "a", value: {str: "123"}}],
+    "The results are unchanged when an extension page adds duplicate items"
+  );
+
+  await contentPage.close();
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: Bg page adds item while inspector is open. Inspector edits item's value.
+* - Load extension with background page.
+* - Open the add-on inspector.
+* - With the inspector still open, add item from the background page.
+* - Edit the value of the item in the inspector
+* - Assert:
+*   - The data in the inspector should match the item added by the extension.
+*   - The storage actor is not mutating the item value's data type
+*     when the item's value is edited in the inspector
+*/
+add_task(async function test_local_storage_value_data_types_unchanged() {
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background: extensionScriptWithMessageListener})
+  );
+
+  await extension.startup();
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  const {target} = await setupExtensionDebugging(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  /*
+  * Compares the data type for the modified value of a storage item between
+  * the extension and the inspector.
+  * @param {Object} item - The storage item to modify
+  * @param {string} newVal - The new value for the storage item, expressed as a string
+  * @param {string} valType - The expected result of 'typeof' once newValue is parsed
+  * in the storage actor
+  * @param {Boolean} inExtension - True if the item's value should be modified
+  * by the extension. False if it should be modified by the storage inspector.
+  * @param {string} parsedVal - Optional - The parsed value obtained in the storage actor.
+  * This is useful for objects where spaces and escape characters can cause two
+  * functionally equivalent values to fail a strict equals check.
+  */
+  async function verifyItemValueType(item, newVal, valType, inExtension, parsedVal) {
+    const key = Object.keys(item)[0];
+    const oldValue = item[key];
+
+    if (inExtension) {
+      extension.sendMessage("storage-local-set", item);
+      await extension.awaitMessage("storage-local-set:done");
+    } else {
+      await extensionStorage.editItem({
+        host,
+        field: "value",
+        items: {area: "local", name: key, value: newVal},
+        oldValue,
+      });
+    }
+
+    const {data} = await extensionStorage.getStoreObjects(host);
+    Assert.deepEqual(
+      data,
+      // The view layer is separate from the database layer; therefore
+      // while the storage actor does change a copy of the value to be a
+      // LongStringActor for the view (by way of `toStoreObject`, the
+      // value's data type in the database is unchanged, as demonstrated
+      // by the next assertion in the test extension.
+      [{area: "local", name: key, value: {str: parsedVal || newVal}}],
+      "Got the expected results on populated storage.local"
+    );
+
+    // The extension asserts the data type is unchanged
+    extension.sendMessage("storage-local-get", {key, valType});
+    await extension.awaitMessage("storage-local-get:done");
+  }
+
+  await verifyItemValueType({a: 123}, "123", "number", true);
+
+  await verifyItemValueType({a: 123}, "true", "boolean", false);
+
+  await verifyItemValueType({a: 123}, "hi", "string", false);
+
+  await verifyItemValueType({a: 123}, "{b: 789}", "object", false, "{\"b\":789}");
+
+  await verifyItemValueType({a: 123}, "[1, 2, 3]", "object", false, "[1,2,3]");
+
+  await verifyItemValueType({a: 123}, "null", "object", false);
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: Inspector shows extension storage data added prior to extension startup
+* - Load extension that adds a storage item
+* - Uninstall the extension
+* - Reinstall the extension
+* - Open the add-on storage inspector.
+* - The data in the inspector should match the data added the first time the extension
+*   was installed
+* Related test case: Inspector shows extension storage data when an extension that has
+* already migrated to the IndexedDB storage backend prior to extension startup adds
+* another storage item.
+* - (Building from previous steps)
+* - The reinstalled extension adds a storage item
+* - The data in the inspector should live update with both items: the item added from the
+*   first and the item added from the reinstall.
+*/
+add_task(async function test_local_storage_ext_data_added_prior_to_ext_startup() {
+  // The pref to leave the addonid->uuid mapping around after uninstall so that we can
+  // re-attach to the same storage
+  Services.prefs.setBoolPref(LEAVE_UUID_PREF, true);
+
+  // The pref to prevent cleaning up storage on uninstall
+  Services.prefs.setBoolPref(LEAVE_STORAGE_PREF, true);
+
+  let extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background: extensionScriptWithMessageListener})
+  );
+
+  await extension.startup();
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  await shutdown(extension);
+
+  // Reinstall the same extension
+  extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({background: extensionScriptWithMessageListener})
+  );
+
+  await extension.startup();
+
+  await extension.awaitMessage("extension-origin");
+
+  const {target} = await setupExtensionDebugging(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  let {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    [{area: "local", name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  // Related test case
+  extension.sendMessage("storage-local-set", {b: 456});
+  await extension.awaitMessage("storage-local-set:done");
+
+  data = (await extensionStorage.getStoreObjects(host)).data;
+  Assert.deepEqual(
+    data,
+    [
+      {area: "local", name: "a", value: {str: "123"}},
+      {area: "local", name: "b", value: {str: "456"}},
+    ],
+    "Got the expected results on populated storage.local"
+  );
+
+  Services.prefs.setBoolPref(LEAVE_STORAGE_PREF, false);
+  Services.prefs.setBoolPref(LEAVE_UUID_PREF, false);
+
+  await shutdown(extension, target);
+});
+
+add_task(function cleanup_for_test_local_storage_ext_data_added_prior_to_ext_startup() {
+  Services.prefs.clearUserPref(LEAVE_UUID_PREF);
+  Services.prefs.clearUserPref(LEAVE_STORAGE_PREF);
+});
+
+/**
+* Test case: Bg page adds an item to storage. With inspector open, reload extension.
+* - Load extension with background page that adds a storage item on message.
+* - Open the add-on inspector.
+* - With the inspector still open, reload the extension.
+* - The data in the inspector should match the item added prior to reloading.
+*/
+add_task(async function test_local_storage_live_reload() {
+  const EXTENSION_ID = "test_local_storage_live_reload@xpcshell.mozilla.org";
+  let manifest = {
+    version: "1.0",
+    applications: {
+      gecko: {
+        id: EXTENSION_ID,
+      },
+    },
+  };
+
+  info("Loading extension version 1.0");
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({
+      manifest,
+      background: extensionScriptWithMessageListener,
+    })
+  );
+
+  info("Starting up extension");
+  await extension.startup();
+
+  info("Waiting for message from test extension");
+  const host = await extension.awaitMessage("extension-origin");
+
+  info("Adding storage item");
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  const {target} = await setupExtensionDebugging(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  manifest = {
+    ...manifest,
+    version: "2.0",
+  };
+  // "Reload" is most similar to an upgrade, as e.g. storage data is preserved
+  info("Update to version 2.0");
+  await extension.upgrade(
+    getExtensionConfig({
+      manifest,
+      background: extensionScriptWithMessageListener,
+    }),
+  );
+
+  await extension.awaitMessage("extension-origin");
+
+  const {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    [{area: "local", name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: Transient page adds an item to storage. With inspector open,
+* reload extension.
+* - Load extension open transient page that adds a storage item on message.
+* - Open the add-on storage inspector.
+* - With the inspector still open, reload the extension.
+* - The data in the inspector should match the item added prior to reloading.
+*/
+add_task(async function test_local_storage_live_reload_no_bg_page() {
+  const EXTENSION_ID = "test_local_storage_live_reload@xpcshell.mozilla.org";
+  let manifest = {
+    version: "1.0",
+    applications: {
+      gecko: {
+        id: EXTENSION_ID,
+      },
+    },
+  };
+
+  info("Loading extension version 1.0");
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig({
+    manifest,
+    files: ext_no_bg.files,
+  }));
+
+  info("Starting up extension");
+  await extension.startup();
+
+  info("Opening extension page in a tab");
+  const url = extension.extension.baseURI.resolve("extension_page_in_tab.html");
+  const contentPage = await ExtensionTestUtils.loadContentPage(url, {extension});
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  info("Waiting for extension page in a tab to add storage item");
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  await contentPage.close();
+
+  info("Opening storage inspector");
+  const {target} = await setupExtensionDebugging(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  manifest = {
+    ...manifest,
+    version: "2.0",
+  };
+  // "Reload" is most similar to an upgrade, as e.g. storage data is preserved
+  info("Updating extension to version 2.0");
+  await extension.upgrade(
+    getExtensionConfig({
+      manifest,
+      files: ext_no_bg.files,
+    })
+  );
+
+  const {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    [{area: "local", name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
+
+/**
+* Test case: Bg page automatically adds item(s). With inspector open, reload extension.
+* - Load extension with background page that automatically adds a storage item on startup.
+* - Open the add-on inspector.
+* - With the inspector still open, reload the extension.
+* - The data in the inspector should match the item(s) added by the reloaded extension.
+*/
+add_task(async function test_local_storage_live_reload_bg_page_auto_adds_items() {
+  async function background() {
+    await browser.storage.local.set({a: {b: 123}, c: {d: 456}});
+    browser.test.sendMessage("extension-origin", window.location.origin);
+  }
+  const EXTENSION_ID = "test_local_storage_live_reload@xpcshell.mozilla.org";
+  let manifest = {
+    version: "1.0",
+    applications: {
+      gecko: {
+        id: EXTENSION_ID,
+      },
+    },
+  };
+
+  info("Loading extension version 1.0");
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig({
+      manifest,
+      background,
+    })
+  );
+
+  info("Starting up extension");
+  await extension.startup();
+
+  info("Waiting for message from test extension");
+  const host = await extension.awaitMessage("extension-origin");
+
+  const {target} = await setupExtensionDebugging(extension.id);
+  // This effectively opens the storage inspector by calling listStores
+  const extensionStorage = await getExtensionStorage(target);
+
+  manifest = {
+    ...manifest,
+    version: "2.0",
+  };
+  // "Reload" is most similar to an upgrade, as e.g. storage data is preserved
+  info("Update to version 2.0");
+  await extension.upgrade(
+    getExtensionConfig({
+      manifest,
+      background,
+    }),
+  );
+
+  await extension.awaitMessage("extension-origin");
+
+  const {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(
+    data,
+    [
+      {area: "local", name: "a", value: {str: "{\"b\":123}"}},
+      {area: "local", name: "c", value: {str: "{\"d\":456}"}},
+    ],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
+
+/*
+* This task should be last, as it sets a pref to disable the extensionStorage
+* storage actor. Since this pref is set at the beginning of the file, it
+* already will be cleared via registerCleanupFunction when the test finishes.
+*/
+add_task(async function test_extension_store_disabled_on_pref() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig());
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebugging(extension.id);
+
+  Services.prefs.setBoolPref(EXTENSION_STORAGE_ENABLED_PREF, false);
+  const extensionStorage = await getExtensionStorage(target);
+  ok(
+    extensionStorage === null,
+    "Should not have an extensionStorage store when pref disabled"
+  );
+
+  await shutdown(extension, target);
+});
diff --git a/devtools/server/tests/unit/xpcshell.ini b/devtools/server/tests/unit/xpcshell.ini
--- a/devtools/server/tests/unit/xpcshell.ini
+++ b/devtools/server/tests/unit/xpcshell.ini
@@ -59,6 +59,7 @@ support-files =
 [test_blackboxing-05.js]
 [test_blackboxing-07.js]
 [test_blackboxing-08.js]
+[test_extension_storage_actor.js]
 [test_frameactor-01.js]
 [test_frameactor-02.js]
 [test_frameactor-03.js]
diff --git a/devtools/shared/moz.build b/devtools/shared/moz.build
--- a/devtools/shared/moz.build
+++ b/devtools/shared/moz.build
@@ -27,6 +27,7 @@ DIRS += [
     'security',
     'sprintfjs',
     'specs',
+    'storage',
     'transport',
     'webconsole',
     'worker',
diff --git a/devtools/shared/specs/storage.js b/devtools/shared/specs/storage.js
--- a/devtools/shared/specs/storage.js
+++ b/devtools/shared/specs/storage.js
@@ -163,6 +163,34 @@ createStorageSpec({
   methods: storageMethods,
 });
 
+types.addDictType("extensionobject", {
+  name: "nullable:string",
+  value: "nullable:longstring",
+});
+
+types.addDictType("extensionstoreobject", {
+  total: "number",
+  offset: "number",
+  data: "array:nullable:extensionobject",
+});
+
+createStorageSpec({
+  typeName: "extensionStorage",
+  storeObjectType: "extensionstoreobject",
+  methods: {
+    ...storageMethods,
+    isEditable: {
+      request: {
+        host: Arg(0, "string"),
+        name: Arg(1, "string"),
+      },
+      response: {
+        value: RetVal("boolean"),
+      },
+    },
+  },
+});
+
 types.addDictType("cacheobject", {
   "url": "string",
   "status": "string",
diff --git a/devtools/shared/storage/moz.build b/devtools/shared/storage/moz.build
new file mode 100644
--- /dev/null
+++ b/devtools/shared/storage/moz.build
@@ -0,0 +1,13 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DIRS += [
+    'vendor'
+]
+
+DevToolsModules(
+    'utils.js'
+)
diff --git a/devtools/shared/storage/utils.js b/devtools/shared/storage/utils.js
new file mode 100644
--- /dev/null
+++ b/devtools/shared/storage/utils.js
@@ -0,0 +1,146 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const validator = require("devtools/shared/storage/vendor/stringvalidator/validator");
+const JSOL = require("devtools/shared/storage/vendor/jsol");
+
+const MATH_REGEX = /(?:(?:^|[-+_*/])(?:\s*-?\d+(\.\d+)?(?:[eE][+-]?\d+)?\s*))+$/;
+
+/**
+ * Tries to parse a string into an object on the basis of key-value pairs,
+ * separated by various separators. If failed, tries to parse for single
+ * separator separated values to form an array.
+ *
+ * @param {string} value
+ *        The string to be parsed into an object or array
+ */
+function _extractKeyValPairs(value) {
+  const makeObject = (keySep, pairSep) => {
+    const object = {};
+    for (const pair of value.split(pairSep)) {
+      const [key, val] = pair.split(keySep);
+      object[key] = val;
+    }
+    return object;
+  };
+
+  // Possible separators.
+  const separators = ["=", ":", "~", "#", "&", "\\*", ",", "\\."];
+  // Testing for object
+  for (let i = 0; i < separators.length; i++) {
+    const kv = separators[i];
+    for (let j = 0; j < separators.length; j++) {
+      if (i == j) {
+        continue;
+      }
+      const p = separators[j];
+      const word = `[^${kv}${p}]*`;
+      const keyValue = `${word}${kv}${word}`;
+      const keyValueList = `${keyValue}(${p}${keyValue})*`;
+      const regex = new RegExp(`^${keyValueList}$`);
+      if (value.match && value.match(regex) && value.includes(kv) &&
+          (value.includes(p) || value.split(kv).length == 2)) {
+        return makeObject(kv, p);
+      }
+    }
+  }
+  // Testing for array
+  for (const p of separators) {
+    const word = `[^${p}]*`;
+    const wordList = `(${word}${p})+${word}`;
+    const regex = new RegExp(`^${wordList}$`);
+
+    if (regex.test(value)) {
+      const pNoBackslash = p.replace(/\\*/g, "");
+      return value.split(pNoBackslash);
+    }
+  }
+  return null;
+}
+
+/**
+ * Check whether the value string represents something that should be
+ * displayed as text. If so then it shouldn't be parsed into a tree.
+ *
+ * @param  {String} value
+ *         The value to be parsed.
+ */
+function _shouldParse(value) {
+  const validators = [
+    "isBase64",
+    "isBoolean",
+    "isCurrency",
+    "isDataURI",
+    "isEmail",
+    "isFQDN",
+    "isHexColor",
+    "isIP",
+    "isISO8601",
+    "isMACAddress",
+    "isSemVer",
+    "isURL",
+  ];
+
+  // Check for minus calculations e.g. 8-3 because otherwise 5 will be displayed.
+  if (MATH_REGEX.test(value)) {
+    return false;
+  }
+
+  // Check for any other types that shouldn't be parsed.
+  for (const test of validators) {
+    if (validator[test](value)) {
+      return false;
+    }
+  }
+
+  // Seems like this is data that should be parsed.
+  return true;
+}
+
+/**
+ * Tries to parse a string value into either a json or a key-value separated
+ * object. The value can also be a key separated array.
+ *
+ * @param {string} originalValue
+ *        The string to be parsed into an object
+ */
+function parseItemValue(originalValue) {
+  // Find if value is URLEncoded ie
+  let decodedValue = "";
+  try {
+    decodedValue = decodeURIComponent(originalValue);
+  } catch (e) {
+    // Unable to decode, nothing to do
+  }
+  const value = (decodedValue && decodedValue !== originalValue)
+    ? decodedValue : originalValue;
+
+  if (!_shouldParse(value)) {
+    return value;
+  }
+
+  let obj = null;
+  try {
+    obj = JSOL.parse(value);
+  } catch (ex) {
+    obj = null;
+  }
+
+  if (!obj && value) {
+    obj = _extractKeyValPairs(value);
+  }
+
+  // return if obj is null, or same as value, or just a string.
+  if (!obj || obj === value || typeof obj === "string") {
+    return value;
+  }
+
+  // If we got this far, originalValue is an object literal or array,
+  // and we have successfully parsed it
+  return obj;
+}
+
+exports.parseItemValue = parseItemValue;
diff --git a/devtools/client/shared/vendor/jsol.js b/devtools/shared/storage/vendor/jsol.js
rename from devtools/client/shared/vendor/jsol.js
rename to devtools/shared/storage/vendor/jsol.js
diff --git a/devtools/shared/storage/vendor/moz.build b/devtools/shared/storage/vendor/moz.build
new file mode 100644
--- /dev/null
+++ b/devtools/shared/storage/vendor/moz.build
@@ -0,0 +1,13 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DIRS += [
+    'stringvalidator',
+]
+
+DevToolsModules(
+    'jsol.js',
+)
diff --git a/devtools/client/shared/vendor/stringvalidator/UPDATING.md b/devtools/shared/storage/vendor/stringvalidator/UPDATING.md
rename from devtools/client/shared/vendor/stringvalidator/UPDATING.md
rename to devtools/shared/storage/vendor/stringvalidator/UPDATING.md
diff --git a/devtools/client/shared/vendor/stringvalidator/moz.build b/devtools/shared/storage/vendor/stringvalidator/moz.build
rename from devtools/client/shared/vendor/stringvalidator/moz.build
rename to devtools/shared/storage/vendor/stringvalidator/moz.build
diff --git a/devtools/client/shared/vendor/stringvalidator/tests/unit/head_stringvalidator.js b/devtools/shared/storage/vendor/stringvalidator/tests/unit/head_stringvalidator.js
rename from devtools/client/shared/vendor/stringvalidator/tests/unit/head_stringvalidator.js
rename to devtools/shared/storage/vendor/stringvalidator/tests/unit/head_stringvalidator.js
diff --git a/devtools/client/shared/vendor/stringvalidator/tests/unit/test_sanitizers.js b/devtools/shared/storage/vendor/stringvalidator/tests/unit/test_sanitizers.js
rename from devtools/client/shared/vendor/stringvalidator/tests/unit/test_sanitizers.js
rename to devtools/shared/storage/vendor/stringvalidator/tests/unit/test_sanitizers.js
diff --git a/devtools/client/shared/vendor/stringvalidator/tests/unit/test_validators.js b/devtools/shared/storage/vendor/stringvalidator/tests/unit/test_validators.js
rename from devtools/client/shared/vendor/stringvalidator/tests/unit/test_validators.js
rename to devtools/shared/storage/vendor/stringvalidator/tests/unit/test_validators.js
diff --git a/devtools/client/shared/vendor/stringvalidator/tests/unit/xpcshell.ini b/devtools/shared/storage/vendor/stringvalidator/tests/unit/xpcshell.ini
rename from devtools/client/shared/vendor/stringvalidator/tests/unit/xpcshell.ini
rename to devtools/shared/storage/vendor/stringvalidator/tests/unit/xpcshell.ini
diff --git a/devtools/client/shared/vendor/stringvalidator/util/assert.js b/devtools/shared/storage/vendor/stringvalidator/util/assert.js
rename from devtools/client/shared/vendor/stringvalidator/util/assert.js
rename to devtools/shared/storage/vendor/stringvalidator/util/assert.js
diff --git a/devtools/client/shared/vendor/stringvalidator/util/moz.build b/devtools/shared/storage/vendor/stringvalidator/util/moz.build
rename from devtools/client/shared/vendor/stringvalidator/util/moz.build
rename to devtools/shared/storage/vendor/stringvalidator/util/moz.build
diff --git a/devtools/client/shared/vendor/stringvalidator/validator.js b/devtools/shared/storage/vendor/stringvalidator/validator.js
rename from devtools/client/shared/vendor/stringvalidator/validator.js
rename to devtools/shared/storage/vendor/stringvalidator/validator.js
diff --git a/toolkit/components/extensions/ExtensionStorageIDB.jsm b/toolkit/components/extensions/ExtensionStorageIDB.jsm
--- a/toolkit/components/extensions/ExtensionStorageIDB.jsm
+++ b/toolkit/components/extensions/ExtensionStorageIDB.jsm
@@ -599,6 +599,11 @@ this.ExtensionStorageIDB = {
         const serializedPrincipal = new StructuredCloneHolder(storagePrincipal, this);
 
         promise = migrateJSONFileData(extension, storagePrincipal).then(() => {
+          extension.setSharedData("storageIDBBackend", true);
+          if (storagePrincipal) {
+            extension.setSharedData("storageIDBPrincipal", storagePrincipal);
+          }
+          Services.ppmm.sharedData.flush();
           return {backendEnabled: true, storagePrincipal: serializedPrincipal};
         }).catch(err => {
           // If the data migration promise is rejected, the old data has been read
@@ -612,6 +617,9 @@ this.ExtensionStorageIDB = {
           // data about it may be useful.
           extension.logWarning("JSONFile backend is being kept enabled by an unexpected " +
                                `IDBBackend failure: ${err.message}::${err.stack}`);
+          extension.setSharedData("storageIDBBackend", false);
+          Services.ppmm.sharedData.flush();
+
           return {backendEnabled: false};
         });
       }
diff --git a/toolkit/components/extensions/parent/ext-storage.js b/toolkit/components/extensions/parent/ext-storage.js
--- a/toolkit/components/extensions/parent/ext-storage.js
+++ b/toolkit/components/extensions/parent/ext-storage.js
@@ -8,6 +8,8 @@ XPCOMUtils.defineLazyModuleGetters(this,
   NativeManifests: "resource://gre/modules/NativeManifests.jsm",
 });
 
+var {ExtensionParent} = ChromeUtils.import("resource://gre/modules/ExtensionParent.jsm");
+
 var {
   ExtensionError,
 } = ExtensionUtils;
@@ -37,6 +39,21 @@ const lookupManagedStorage = async (exte
   return null;
 };
 
+// Notify storage actor when storage data has changed if the extension is targeted
+// by a developer toolbox.
+function notifyDevToolsListeners(extension, changes) {
+  const {DebugUtils} = ExtensionParent;
+  let debugBrowserPromise = DebugUtils.debugBrowserPromises.get(extension.id);
+  if (debugBrowserPromise) {
+    (async () => {
+      const browser = await debugBrowserPromise;
+      browser.messageManager.sendAsyncMessage(
+        `Extension:DevTools:OnStorageLocalChanged`,
+        {changes, extensionUUID: extension.uuid});
+    })();
+  }
+}
+
 this.storage = class extends ExtensionAPI {
   constructor(extension) {
     super(extension);
@@ -82,6 +99,7 @@ this.storage = class extends ExtensionAP
             const changes = await db[method](...args);
             if (changes) {
               ExtensionStorageIDB.notifyListeners(extension.id, changes);
+              notifyDevToolsListeners(extension, changes);
             }
             return changes;
           },
