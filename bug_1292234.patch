# HG changeset patch
# User Bianca Danforth <bdanforth@mozilla.com>
# Date 1553039428 25200
#      Tue Mar 19 16:50:28 2019 -0700
# Node ID b7520451f3e62c56376824783d29516c8674a20e
# Parent  3d5cd10cb1b20c1f83a189fbeb2e22f470bac0ec
Bug 1292234 - Prototype extension storage in addon developer toolbox

diff --git a/devtools/server/actors/storage.js b/devtools/server/actors/storage.js
--- a/devtools/server/actors/storage.js
+++ b/devtools/server/actors/storage.js
@@ -12,12 +12,16 @@ const Services = require("Services");
 const defer = require("devtools/shared/defer");
 const {isWindowIncluded} = require("devtools/shared/layout/utils");
 const specs = require("devtools/shared/specs/storage");
+const {ExtensionProcessScript} = require("resource://gre/modules/ExtensionProcessScript.jsm");
+const {ExtensionStorageIDB} = require("resource://gre/modules/ExtensionStorageIDB.jsm");
 
 const CHROME_ENABLED_PREF = "devtools.chrome.enabled";
 const REMOTE_ENABLED_PREF = "devtools.debugger.remote-enabled";
 
 const DEFAULT_VALUE = "value";
 
+const DEVTOOLS_EXT_STORAGELOCAL_CHANGED = "Extension:DevTools:OnStorageLocalChanged";
+
 loader.lazyRequireGetter(this, "naturalSortCaseInsensitive",
   "devtools/client/shared/natural-sort", true);
 
@@ -1298,6 +1302,279 @@ StorageActors.createActor({
   observationTopics: ["dom-storage2-changed", "dom-private-storage2-changed"],
 }, getObjectForLocalOrSessionStorage("sessionStorage"));
 
+/**
+* The Extension Storage actor.
+*/
+StorageActors.createActor({
+  typeName: "extensionStorage",
+}, {
+  initialize(storageActor) {
+    protocol.Actor.prototype.initialize.call(this, null);
+
+    this.storageActor = storageActor;
+
+    // Map<host, ExtensionStorageIDB db connection>
+    this.dbConnectionForHost = new Map();
+
+    this.onStorageChange = this.onStorageChange.bind(this);
+
+    this.conn.parentMessageManager.addMessageListener(
+      DEVTOOLS_EXT_STORAGELOCAL_CHANGED, this.onStorageChange);
+
+    this.populateStoresForHosts();
+
+    this.onWindowReady = this.onWindowReady.bind(this);
+    this.onWindowDestroyed = this.onWindowDestroyed.bind(this);
+    this.storageActor.on("window-ready", this.onWindowReady);
+    this.storageActor.on("window-destroyed", this.onWindowDestroyed);
+  },
+
+  destroy() {
+    this.conn.parentMessageManager.removeMessageListener(
+      DEVTOOLS_EXT_STORAGELOCAL_CHANGED, this.onStorageChange);
+
+    this.storageActor.off("window-ready", this.onWindowReady);
+    this.storageActor.off("window-destroyed", this.onWindowDestroyed);
+
+    this.hostVsStores.clear();
+
+    protocol.Actor.prototype.destroy.call(this);
+
+    this.storageActor = null;
+  },
+
+  /**
+  * This fires when the extension changes storage data while the storage
+  * inspector is open. Ensures this.hostVsStores stays up-to-date and
+  * passes the change on to update the view.
+  */
+  onStorageChange({name, data}) {
+    const host = `moz-extension://${data.extensionUUID}`;
+    const changes = data.changes;
+    const storeMap = this.hostVsStores.get(host);
+    if (!storeMap) {
+      return;
+    }
+
+    for (const key in changes) {
+      const storageChange = changes[key];
+      const {newValue, oldValue} = storageChange;
+
+      let action;
+      if (typeof newValue === "undefined") {
+        action = "deleted";
+        storeMap.delete(key);
+      } else if (typeof oldValue === "undefined") {
+        action = "added";
+        storeMap.set(key, newValue);
+      } else {
+        action = "changed";
+        storeMap.set(key, newValue);
+      }
+
+      this.storageActor.update(action, this.typeName, {[host]: [key]});
+    }
+  },
+
+  /**
+   * This method is overriden and left blank as for extensionStorage, this operation
+   * cannot be performed synchronously. Thus, the preListStores method exists to
+   * do the same task asynchronously.
+   */
+  populateStoresForHosts() {},
+
+  /**
+   * Purpose of this method is same as populateStoresForHosts but this is async.
+   * This exact same operation cannot be performed in populateStoresForHosts
+   * method, as that method is called in initialize method of the actor, which
+   * cannot be asynchronous.
+   */
+  async preListStores() {
+    this.hostVsStores = new Map();
+
+    for (const window of this.windows) {
+      const host = this.getHostName(window.location);
+      if (host) {
+        await this.populateStoresForHost(host, window);
+      }
+    }
+  },
+
+  async getStoragePrincipal(extension) {
+    if (extension.getSharedData("storageIDBBackend")) {
+      return extension.getSharedData("storageIDBPrincipal");
+    }
+    // This extension either isn't using the IDB backend (false) or
+    // it hasn't migrated to the IDB backend yet (null)
+
+    // Loop for web extension context related to the current window
+    let currentContext;
+    for (const view of extension.views) {
+      currentContext = view;
+    }
+    if (!currentContext) {
+      // We didn't find the extension context for the current target; give up.
+      return null;
+    }
+    const {
+      backendEnabled,
+      storagePrincipal,
+    } = await ExtensionStorageIDB.selectBackend(currentContext);
+
+    if (!backendEnabled) {
+      // IDB backend disabled; give up.
+      return null;
+    }
+    return storagePrincipal;
+  },
+
+  /**
+  * This method asynchronously reads the browser.storage.local data for the window
+  * (if it's an extension page window and the related extension has the storage
+  * permission) and caches this data into this.hostVsStores.
+  */
+  async populateStoresForHost(host, window = this.storageActor.window) {
+    if (this.hostVsStores.has(host)) {
+      return;
+    }
+
+    const principal = this.getPrincipal(window);
+    const extension = ExtensionProcessScript.getExtensionChild(principal.addonId);
+
+    if (!extension || !(extension.hasPermission("storage"))) {
+      return;
+    }
+
+    const storagePrincipal = await this.getStoragePrincipal(extension);
+
+    if (!storagePrincipal) {
+      return;
+    }
+
+    const db = await ExtensionStorageIDB.open(storagePrincipal);
+    this.dbConnectionForHost.set(host, db);
+    const data = await db.get();
+
+    const storeMap = new Map();
+    for (const [key, value] of Object.entries(data)) {
+      storeMap.set(key, value);
+    }
+
+    this.hostVsStores.set(host, storeMap);
+  },
+
+  getValuesForHost(host, name) {
+    const result = [];
+
+    if (!this.hostVsStores.has(host)) {
+      return result;
+    }
+
+    if (name) {
+      return [{name, value: this.hostVsStores.get(host).get(name)}];
+    }
+
+    for (const [key, value] of Array.from(this.hostVsStores.get(host).entries())) {
+      result.push({name: key, value});
+    }
+    return result;
+  },
+
+  /**
+   * This method converts the values returned by getValuesForHost into a StoreObject
+   * (currently based off of this same method for IndexedDB).
+   */
+  toStoreObject({name, value}) {
+    if (!{name, value}) {
+      return null;
+    }
+
+    // Stringify adds redundant quotes to strings
+    if (typeof value !== "string") {
+      // Not all possible values are stringifiable (e.g. functions)
+      value = JSON.stringify(value) || "Object";
+    }
+
+    // FIXME: Bug 1318029 - Due to a bug that is thrown whenever a
+    // LongStringActor string reaches DebuggerServer.LONG_STRING_LENGTH we need
+    // to trim the value. When the bug is fixed we should stop trimming the
+    // string here.
+    const maxLength = DebuggerServer.LONG_STRING_LENGTH - 1;
+    if (value.length > maxLength) {
+      value = value.substr(0, maxLength);
+    }
+
+    return {
+      name,
+      value: new LongStringActor(this.conn, value || ""),
+    };
+  },
+
+  getFields() {
+    return [
+      // name needs to be editable for the addItem case, where a temporary key-value
+      // pair is created that can later be edited via editItem.
+      { name: "name", editable: true },
+      { name: "value", editable: true },
+    ];
+  },
+
+  async addItem(guid, host) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+    const changes = await db.set({[guid]: DEFAULT_VALUE});
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async editItem({host, field, items, oldValue}) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const {name, value} = items;
+    // If the name changed, remove the previous entry in storage by the old name first
+    if (field === "name") {
+      const changes = await db.remove(oldValue);
+      this.fireOnChangedExtensionEvent(host, changes);
+    }
+    const changes = await db.set({[name]: value});
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async removeItem(host, name) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const changes = await db.remove(name);
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async removeAll(host) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const changes = await db.clear();
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  /**
+  * Let the extension know that storage data has been changed by the user from
+  * the storage inspector.
+  */
+  fireOnChangedExtensionEvent(host, changes) {
+    const uuid = (new URL(host)).host;
+    Services.cpmm.sendAsyncMessage(`Extension:StorageLocalOnChanged:${uuid}`,
+                                   changes);
+  },
+});
+
 StorageActors.createActor({
   typeName: "Cache",
 }, {
diff --git a/devtools/server/tests/browser/browser.ini b/devtools/server/tests/browser/browser.ini
--- a/devtools/server/tests/browser/browser.ini
+++ b/devtools/server/tests/browser/browser.ini
@@ -122,6 +122,7 @@ skip-if = e10s # Bug 1183605 - devtools/
 [browser_storage_listings.js]
 [browser_storage_updates.js]
 skip-if = (verify && debug && (os == 'mac' || os == 'linux'))
+[browser_storage_webext_storage_local.js]
 [browser_stylesheets_getTextEmpty.js]
 [browser_stylesheets_nested-iframes.js]
 [browser_register_actor.js]
diff --git a/devtools/server/tests/browser/browser_storage_webext_storage_local.js b/devtools/server/tests/browser/browser_storage_webext_storage_local.js
new file mode 100644
--- /dev/null
+++ b/devtools/server/tests/browser/browser_storage_webext_storage_local.js
@@ -0,0 +1,175 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/* globals browser */
+
+"use strict";
+
+/**
+* This test verifies that web extension local storage (i.e. `browser.storage.local`)
+* data is correctly synced between the `about:debugging` toolbox's Storage panel and a
+* test extension.
+*/
+
+const {Toolbox} = require("devtools/client/framework/toolbox");
+
+/**
+* Starts up and connects the Debugger server to the DevTools client (both in the main
+* process) by listening over an nsIPipe, so that they can send remote debugging
+* protocol messages to each other.
+* @return {Promise} Resolves with a client object when the debugger has started up.
+*/
+async function startDebugger() {
+  initDebuggerServer();
+  const transport = DebuggerServer.connectPipe();
+  const client = new DebuggerClient(transport);
+  await client.connect();
+  return client;
+}
+
+/**
+* Set up and optionally open the `about:debugging` toolbox for a given extension.
+* @param {String} extensionId - The id for the extension to be targeted by the toolbox.
+* @param {Object} options - Configuration options with various optional fields:
+*   - {Boolean} openToolbox - If true, open the toolbox
+* @return {Promise} Resolves with a web extension actor front and target objects and a
+* toolbox object when the toolbox has been setup
+*/
+async function setupExtensionDebuggingToolbox(extensionId, options = {}) {
+  const {openToolbox = false} = options;
+
+  const client = await startDebugger();
+  const front = await client.mainRoot.getAddon({id: extensionId});
+  // This is the web extension actor the toolbox will target
+  const target = await front.connect();
+
+  const toolbox = openToolbox ?
+    await gDevTools.showToolbox(target, null, Toolbox.HostType.WINDOW) : null;
+
+  return {front, target, toolbox};
+}
+
+/**
+* Builds the extension configuration object passed into ExtensionTestUtils.loadExtension
+* @param {Function} backgroundScript - (optional) a function comprising the test
+* extension's background script if provided
+* @return {Object} - The extension configuration object
+*/
+function getExtensionConfig(backgroundScript) {
+  const baseConfig = {
+    manifest: {
+      permissions: ["storage"],
+    },
+    useAddonManager: "temporary",
+  };
+  if (!backgroundScript) {
+    return baseConfig;
+  }
+  return {
+    background: `(${backgroundScript})()`,
+    ...baseConfig,
+  };
+}
+
+/**
+* Gets the extensionStorage store object from the storage actor in the extension process
+* for the target extension
+* @param {Object} target
+* @return {Promise} Resolves with an extensionStorage store object else null when all
+* stores have been obtained
+*/
+async function getExtensionStorage(target) {
+  const storageFront = await target.getFront("storage");
+  const stores = await storageFront.listStores();
+  return (stores.extensionStorage || null);
+}
+
+/**
+* Shutdown procedure common to all tasks.
+* @param {Object} extension
+* @param {Object} target
+*/
+async function shutdown(extension, target) {
+  await target.destroy();
+  await extension.unload();
+}
+
+add_task(async function test_extension_store_exists() {
+  const extension = ExtensionTestUtils.loadExtension(getExtensionConfig());
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  const extensionStorage = await getExtensionStorage(target);
+  ok(extensionStorage, "Should have an extensionStorage store");
+
+  await shutdown(extension, target);
+});
+
+add_task(async function test_extension_origin_matches_debugger_target() {
+  async function backgroundScript() {
+    browser.test.sendMessage("extension-origin", window.location.origin);
+  }
+
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig(backgroundScript)
+  );
+
+  await extension.startup();
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  const {hosts} = await getExtensionStorage(target);
+  const expectedHost = await extension.awaitMessage("extension-origin");
+  ok(expectedHost in hosts,
+     "Should have the expected extension host in the extensionStorage store");
+
+  await shutdown(extension, target);
+});
+
+add_task(async function test_local_storage_update() {
+  async function backgroundScript() {
+    browser.test.onMessage.addListener(async (msg, ...args) => {
+      switch (msg) {
+        case "storage-local-set":
+          await browser.storage.local.set(args[0]);
+          break;
+        default:
+          browser.test.fail(`Unexpected test message: ${msg}`);
+      }
+
+      browser.test.sendMessage(`${msg}:done`);
+    });
+
+    browser.test.sendMessage("extension-origin", window.location.origin);
+  }
+
+  const extension = ExtensionTestUtils.loadExtension(
+    getExtensionConfig(backgroundScript)
+  );
+
+  await extension.startup();
+
+  const host = await extension.awaitMessage("extension-origin");
+
+  const {target} = await setupExtensionDebuggingToolbox(extension.id);
+  // Don't destructure getStoreObjects here, else 'this' binding fails when it's called
+  const extensionStorage = await getExtensionStorage(target);
+
+  let {data} = await extensionStorage.getStoreObjects(host);
+  Assert.deepEqual(data, [], "Got the expected results on empty storage.local");
+
+  extension.sendMessage("storage-local-set", {a: 123});
+  await extension.awaitMessage("storage-local-set:done");
+
+  data = (await extensionStorage.getStoreObjects(host)).data;
+  Assert.deepEqual(
+    data,
+    // TODO: value is likely a string because of the storage object spec,
+    // but it should actually reflect the actual stored type.
+    [{name: "a", value: {str: "123"}}],
+    "Got the expected results on populated storage.local"
+  );
+
+  await shutdown(extension, target);
+});
diff --git a/devtools/shared/specs/storage.js b/devtools/shared/specs/storage.js
--- a/devtools/shared/specs/storage.js
+++ b/devtools/shared/specs/storage.js
@@ -163,6 +163,40 @@ createStorageSpec({
   methods: storageMethods,
 });
 
+// TODO: create a new storeObjectType, since extension storage is less
+// restrictive than localStorage/sessionStorage and more restrictive than
+// IndexedDB.
+// Extension store object
+types.addDictType("extensionobject", {
+  name: "nullable:string",
+  value: "nullable:longstring",
+});
+
+// Array of Extension Storage store objects
+types.addDictType("extensionstoreobject", {
+  total: "number",
+  offset: "number",
+  data: "array:nullable:extensionobject",
+});
+
+createStorageSpec({
+  typeName: "extensionStorage",
+  storeObjectType: "extensionstoreobject",
+  methods: {
+    // TODO: May want to define storageMethods differently compared to
+    // localStorage and sessionStorage...
+    ...storageMethods,
+    addExtensionStorageListeners: {
+      request: {},
+      response: {},
+    },
+    removeExtensionStorageListeners: {
+      request: {},
+      response: {},
+    },
+  },
+});
+
 types.addDictType("cacheobject", {
   "url": "string",
   "status": "string",
diff --git a/toolkit/components/extensions/parent/ext-storage.js b/toolkit/components/extensions/parent/ext-storage.js
--- a/toolkit/components/extensions/parent/ext-storage.js
+++ b/toolkit/components/extensions/parent/ext-storage.js
@@ -1,5 +1,7 @@
 "use strict";
 
+/* global ExtensionParent */
+
 XPCOMUtils.defineLazyModuleGetters(this, {
   AddonManagerPrivate: "resource://gre/modules/AddonManager.jsm",
   ExtensionStorage: "resource://gre/modules/ExtensionStorage.jsm",
@@ -37,6 +39,21 @@ const lookupManagedStorage = async (exte
   return null;
 };
 
+// Notify storage actor when storage data has changed if the extension is targeted
+// by a developer toolbox.
+function notifyDevToolsListeners(extension, changes) {
+  const {DebugUtils} = ExtensionParent;
+  let debugBrowserPromise = DebugUtils.debugBrowserPromises.get(extension.id);
+  if (debugBrowserPromise) {
+    (async () => {
+      const browser = await debugBrowserPromise;
+      browser.messageManager.sendAsyncMessage(
+        `Extension:DevTools:OnStorageLocalChanged`,
+        {changes, extensionUUID: extension.uuid});
+    })();
+  }
+}
+
 this.storage = class extends ExtensionAPI {
   constructor(extension) {
     super(extension);
@@ -63,6 +80,8 @@ this.storage = class extends ExtensionAP
     }
 
     ExtensionStorageIDB.notifyListeners(this.extension.id, data);
+
+    notifyDevToolsListeners(this.extension, data);
   }
 
   getAPI(context) {
@@ -82,6 +101,7 @@ this.storage = class extends ExtensionAP
             const changes = await db[method](...args);
             if (changes) {
               ExtensionStorageIDB.notifyListeners(extension.id, changes);
+              notifyDevToolsListeners(extension, changes);
             }
             return changes;
           },
