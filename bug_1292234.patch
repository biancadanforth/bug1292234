# HG changeset patch
# User Bianca Danforth <bdanforth@mozilla.com>
# Date 1553039428 25200
#      Tue Mar 19 16:50:28 2019 -0700
# Node ID edfd1d90740f3d699cb022b76de2200f8f822d6b
# Parent  25398e555020fef80c7b2a06a0d4c667e861cd6f
Bug 1292234 - Prototype extension storage in addon developer toolbox

diff --git a/devtools/server/actors/storage.js b/devtools/server/actors/storage.js
--- a/devtools/server/actors/storage.js
+++ b/devtools/server/actors/storage.js
@@ -12,12 +12,16 @@ const Services = require("Services");
 const defer = require("devtools/shared/defer");
 const {isWindowIncluded} = require("devtools/shared/layout/utils");
 const specs = require("devtools/shared/specs/storage");
+const {ExtensionProcessScript} = require("resource://gre/modules/ExtensionProcessScript.jsm");
+const {ExtensionStorageIDB} = require("resource://gre/modules/ExtensionStorageIDB.jsm");
 
 const CHROME_ENABLED_PREF = "devtools.chrome.enabled";
 const REMOTE_ENABLED_PREF = "devtools.debugger.remote-enabled";
 
 const DEFAULT_VALUE = "value";
 
+const DEVTOOLS_EXT_STORAGELOCAL_CHANGED = "Extension:DevTools:OnStorageLocalChanged";
+
 loader.lazyRequireGetter(this, "naturalSortCaseInsensitive",
   "devtools/client/shared/natural-sort", true);
 
@@ -1298,6 +1302,279 @@ StorageActors.createActor({
   observationTopics: ["dom-storage2-changed", "dom-private-storage2-changed"],
 }, getObjectForLocalOrSessionStorage("sessionStorage"));
 
+/**
+* The Extension Storage actor.
+*/
+StorageActors.createActor({
+  typeName: "extensionStorage",
+}, {
+  initialize(storageActor) {
+    protocol.Actor.prototype.initialize.call(this, null);
+
+    this.storageActor = storageActor;
+
+    // Map<host, ExtensionStorageIDB db connection>
+    this.dbConnectionForHost = new Map();
+
+    this.onStorageChange = this.onStorageChange.bind(this);
+
+    this.conn.parentMessageManager.addMessageListener(
+      DEVTOOLS_EXT_STORAGELOCAL_CHANGED, this.onStorageChange);
+
+    this.populateStoresForHosts();
+
+    this.onWindowReady = this.onWindowReady.bind(this);
+    this.onWindowDestroyed = this.onWindowDestroyed.bind(this);
+    this.storageActor.on("window-ready", this.onWindowReady);
+    this.storageActor.on("window-destroyed", this.onWindowDestroyed);
+  },
+
+  destroy() {
+    this.conn.parentMessageManager.removeMessageListener(
+      DEVTOOLS_EXT_STORAGELOCAL_CHANGED, this.onStorageChange);
+
+    this.storageActor.off("window-ready", this.onWindowReady);
+    this.storageActor.off("window-destroyed", this.onWindowDestroyed);
+
+    this.hostVsStores.clear();
+
+    protocol.Actor.prototype.destroy.call(this);
+
+    this.storageActor = null;
+  },
+
+  /**
+  * This fires when the extension changes storage data while the storage
+  * inspector is open. Ensures this.hostVsStores stays up-to-date and
+  * passes the change on to update the view.
+  */
+  onStorageChange({name, data}) {
+    const host = `moz-extension://${data.extensionUUID}`;
+    const changes = data.changes;
+    const storeMap = this.hostVsStores.get(host);
+    if (!storeMap) {
+      return;
+    }
+
+    for (const key in changes) {
+      const storageChange = changes[key];
+      const {newValue, oldValue} = storageChange;
+
+      let action;
+      if (typeof newValue === "undefined") {
+        action = "deleted";
+        storeMap.delete(key);
+      } else if (typeof oldValue === "undefined") {
+        action = "added";
+        storeMap.set(key, newValue);
+      } else {
+        action = "changed";
+        storeMap.set(key, newValue);
+      }
+
+      this.storageActor.update(action, this.typeName, {[host]: [key]});
+    }
+  },
+
+  /**
+   * This method is overriden and left blank as for extensionStorage, this operation
+   * cannot be performed synchronously. Thus, the preListStores method exists to
+   * do the same task asynchronously.
+   */
+  populateStoresForHosts() {},
+
+  /**
+   * Purpose of this method is same as populateStoresForHosts but this is async.
+   * This exact same operation cannot be performed in populateStoresForHosts
+   * method, as that method is called in initialize method of the actor, which
+   * cannot be asynchronous.
+   */
+  async preListStores() {
+    this.hostVsStores = new Map();
+
+    for (const window of this.windows) {
+      const host = this.getHostName(window.location);
+      if (host) {
+        await this.populateStoresForHost(host, window);
+      }
+    }
+  },
+
+  async getStoragePrincipal(extension) {
+    if (extension.getSharedData("storageIDBBackend")) {
+      return extension.getSharedData("storageIDBPrincipal");
+    }
+    // This extension either isn't using the IDB backend (false) or
+    // it hasn't migrated to the IDB backend yet (null)
+
+    // Loop for web extension context related to the current window
+    let currentContext;
+    for (const view of extension.views) {
+      currentContext = view;
+    }
+    if (!currentContext) {
+      // We didn't find the extension context for the current target; give up.
+      return null;
+    }
+    const {
+      backendEnabled,
+      storagePrincipal,
+    } = await ExtensionStorageIDB.selectBackend(currentContext);
+
+    if (!backendEnabled) {
+      // IDB backend disabled; give up.
+      return null;
+    }
+    return storagePrincipal;
+  },
+
+  /**
+  * This method asynchronously reads the browser.storage.local data for the window
+  * (if it's an extension page window and the related extension has the storage
+  * permission) and caches this data into this.hostVsStores.
+  */
+  async populateStoresForHost(host, window = this.storageActor.window) {
+    if (this.hostVsStores.has(host)) {
+      return;
+    }
+
+    const principal = this.getPrincipal(window);
+    const extension = ExtensionProcessScript.getExtensionChild(principal.addonId);
+
+    if (!extension || !(extension.hasPermission("storage"))) {
+      return;
+    }
+
+    const storagePrincipal = await this.getStoragePrincipal(extension);
+
+    if (!storagePrincipal) {
+      return;
+    }
+
+    const db = await ExtensionStorageIDB.open(storagePrincipal);
+    this.dbConnectionForHost.set(host, db);
+    const data = await db.get();
+
+    const storeMap = new Map();
+    for (const [key, value] of Object.entries(data)) {
+      storeMap.set(key, value);
+    }
+
+    this.hostVsStores.set(host, storeMap);
+  },
+
+  getValuesForHost(host, name) {
+    const result = [];
+
+    if (!this.hostVsStores.has(host)) {
+      return result;
+    }
+
+    if (name) {
+      return [{name, value: this.hostVsStores.get(host).get(name)}];
+    }
+
+    for (const [key, value] of Array.from(this.hostVsStores.get(host).entries())) {
+      result.push({name: key, value});
+    }
+    return result;
+  },
+
+  /**
+   * This method converts the values returned by getValuesForHost into a StoreObject
+   * (currently based off of this same method for IndexedDB).
+   */
+  toStoreObject({name, value}) {
+    if (!{name, value}) {
+      return null;
+    }
+
+    // Stringify adds redundant quotes to strings
+    if (typeof value !== "string") {
+      // Not all possible values are stringifiable (e.g. functions)
+      value = JSON.stringify(value) || "Object";
+    }
+
+    // FIXME: Bug 1318029 - Due to a bug that is thrown whenever a
+    // LongStringActor string reaches DebuggerServer.LONG_STRING_LENGTH we need
+    // to trim the value. When the bug is fixed we should stop trimming the
+    // string here.
+    const maxLength = DebuggerServer.LONG_STRING_LENGTH - 1;
+    if (value.length > maxLength) {
+      value = value.substr(0, maxLength);
+    }
+
+    return {
+      name,
+      value: new LongStringActor(this.conn, value || ""),
+    };
+  },
+
+  getFields() {
+    return [
+      // name needs to be editable for the addItem case, where a temporary key-value
+      // pair is created that can later be edited via editItem.
+      { name: "name", editable: true },
+      { name: "value", editable: true },
+    ];
+  },
+
+  async addItem(guid, host) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+    const changes = await db.set({[guid]: DEFAULT_VALUE});
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async editItem({host, field, items, oldValue}) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const {name, value} = items;
+    // If the name changed, remove the previous entry in storage by the old name first
+    if (field === "name") {
+      const changes = await db.remove(oldValue);
+      this.fireOnChangedExtensionEvent(host, changes);
+    }
+    const changes = await db.set({[name]: value});
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async removeItem(host, name) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const changes = await db.remove(name);
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  async removeAll(host) {
+    const db = this.dbConnectionForHost.get(host);
+    if (!db) {
+      return;
+    }
+
+    const changes = await db.clear();
+    this.fireOnChangedExtensionEvent(host, changes);
+  },
+
+  /**
+  * Let the extension know that storage data has been changed by the user from
+  * the storage inspector.
+  */
+  fireOnChangedExtensionEvent(host, changes) {
+    const uuid = (new URL(host)).host;
+    Services.cpmm.sendAsyncMessage(`Extension:StorageLocalOnChanged:${uuid}`,
+                                   changes);
+  },
+});
+
 StorageActors.createActor({
   typeName: "Cache",
 }, {
diff --git a/devtools/shared/specs/storage.js b/devtools/shared/specs/storage.js
--- a/devtools/shared/specs/storage.js
+++ b/devtools/shared/specs/storage.js
@@ -163,6 +163,40 @@ createStorageSpec({
   methods: storageMethods,
 });
 
+// TODO: create a new storeObjectType, since extension storage is less
+// restrictive than localStorage/sessionStorage and more restrictive than
+// IndexedDB.
+// Extension store object
+types.addDictType("extensionobject", {
+  name: "nullable:string",
+  value: "nullable:longstring",
+});
+
+// Array of Extension Storage store objects
+types.addDictType("extensionstoreobject", {
+  total: "number",
+  offset: "number",
+  data: "array:nullable:extensionobject",
+});
+
+createStorageSpec({
+  typeName: "extensionStorage",
+  storeObjectType: "extensionstoreobject",
+  methods: {
+    // TODO: May want to define storageMethods differently compared to
+    // localStorage and sessionStorage...
+    ...storageMethods,
+    addExtensionStorageListeners: {
+      request: {},
+      response: {},
+    },
+    removeExtensionStorageListeners: {
+      request: {},
+      response: {},
+    },
+  },
+});
+
 types.addDictType("cacheobject", {
   "url": "string",
   "status": "string",
diff --git a/toolkit/components/extensions/parent/ext-storage.js b/toolkit/components/extensions/parent/ext-storage.js
--- a/toolkit/components/extensions/parent/ext-storage.js
+++ b/toolkit/components/extensions/parent/ext-storage.js
@@ -1,5 +1,7 @@
 "use strict";
 
+/* global ExtensionParent */
+
 XPCOMUtils.defineLazyModuleGetters(this, {
   AddonManagerPrivate: "resource://gre/modules/AddonManager.jsm",
   ExtensionStorage: "resource://gre/modules/ExtensionStorage.jsm",
@@ -37,6 +39,21 @@ const lookupManagedStorage = async (exte
   return null;
 };
 
+// Notify storage actor when storage data has changed if the extension is targeted
+// by a developer toolbox.
+function notifyDevToolsListeners(extension, changes) {
+  const {DebugUtils} = ExtensionParent;
+  let debugBrowserPromise = DebugUtils.debugBrowserPromises.get(extension.id);
+  if (debugBrowserPromise) {
+    (async () => {
+      const browser = await debugBrowserPromise;
+      browser.messageManager.sendAsyncMessage(
+        `Extension:DevTools:OnStorageLocalChanged`,
+        {changes, extensionUUID: extension.uuid});
+    })();
+  }
+}
+
 this.storage = class extends ExtensionAPI {
   constructor(extension) {
     super(extension);
@@ -63,6 +80,8 @@ this.storage = class extends ExtensionAP
     }
 
     ExtensionStorageIDB.notifyListeners(this.extension.id, data);
+
+    notifyDevToolsListeners(this.extension, data);
   }
 
   getAPI(context) {
@@ -82,6 +101,7 @@ this.storage = class extends ExtensionAP
             const changes = await db[method](...args);
             if (changes) {
               ExtensionStorageIDB.notifyListeners(extension.id, changes);
+              notifyDevToolsListeners(extension, changes);
             }
             return changes;
           },
